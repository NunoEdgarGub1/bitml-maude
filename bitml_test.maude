cd /home/nicola/repositories/bitml-sem
load bitml.maude

mod TEST is 
    protecting BITML-CHECK .
    ops A B A' B' : -> Participant .
    ops x x' x'' : -> Name .
    ops y y' y'' : -> Name .
    ops z z' z'' : -> Name .
    ops v v' v'' : -> Value .
    ops a a' a'' : -> Secret .
    ops b b' b'' : -> Secret .
    ops x^ y^ z^ : -> List{Name} . 
    ops v^ : -> List{Value} . 
    ops a^ b^ : -> List{Secret} . 
    ops t t' : -> Nat .
    ops p p' p'' : -> Predicate .
    ops C C' C'' : -> Contract .
    ops D D' D'' : -> GuardedContract .
    ops l l' l'' : -> Label .
    
    vars SS SS' : Configuration .
    vars ll ll' : Label .
    vars xx^ : List{Name} .

    ops Ex0 Ex1 Ex2 : -> LConfiguration .

    eq Ex0 = < withdraw A , v(10) > x .     *** contract
    eq Ex1 = < A , v(10) > x .              *** deposit
    eq Ex2 = < split(                       *** split
        v(1) ~> C
        v(2) ~> C'
        v(3) ~> (0).Contract
    ), v(6) > x .

endm

rewrite in TEST :
    < A : after 2 : withdraw B, v > x
    | A[x |> A : after 2 : withdraw B] .

rewrite in TEST : [x] < empty : after 5 : (withdraw B + withdraw A + withdraw A'), v > x .

rewrite in TEST : < 0 (3 5).List{Nat<} > [x] < after 5 : tau . after 3 : withdraw B , v > x .

rewrite in TEST :
    < 0 nil >
    [x("x_0")]
    < split(
        v(2) ~> ( reveal b if const(0) <= ref(b) <= const(1) . withdraw B + after t : withdraw A )
        v(2) ~> ( reveal a . withdraw A + after t : withdraw B )
        v(2) ~> ( reveal (a b) if | ref(a) | == | ref(b) | . withdraw A
                + reveal (a b) if | ref(a) | != | ref(b) | . withdraw B ) ), v(6) > x("x_0") .

cd /home/nicola/repositories/MUnit
load mUnit.maude
(munit TEST is
    assertEqual(put x . 0, put x reveal nil if true . 0)
    assertEqual(put x if p . 0, put x reveal nil if p . 0)
    assertEqual(reveal a . 0, put nil reveal a if true . 0)
    assertEqual(reveal a if p . 0, put nil reveal a if p . 0)
    assertEqual(put x reveal a . 0, put x reveal a if true . 0)
	
    assertEqual(after 0 : D, D)
    assertEqual(after 5 : after 10 : D, after 10 : D)

    assertEqual(A : A : D, A : D)
    assertEqual(A : B : D, (A, B) : D)
    assertEqual(A : B : A : D, (A, B) : D)
    assertEqual((B, A) : D, (A, B) : D)

    assertTrue([x] < after 5 : tau . after 3 : withdraw B , v > x |= fvAreTraced)
    assertFalse([y x] < after 5 : tau . after 3 : withdraw B , v > x |= fvAreTraced)
    assertFalse([x] < after 5 : tau . after 3 : withdraw B , v > y | < after 5 : tau . after 3 : withdraw B , v > x |= fvAreTraced)

    assertEqual( < (A, B) : D, v > x, < (A, B) : D, v > x ) *** does not parse    
endu)