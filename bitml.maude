fmod BITML-SORTS is
    protecting NAT .
    protecting INT .
    protecting FLOAT .
    protecting STRING .
    protecting CONVERSION .
    protecting EXT-BOOL .   *** for short-circuit operations _and-then_ _or-else_
    protecting QID .

    sort Participant .      *** A B
    sort Value .            *** v v'
    sort Name .             *** x x' y y'
    sort Secret .           *** s s'
    sort SplitEntry .       *** v -> C
    sort AnonDeposit .      *** <A,v>
    sort AnonContract .     *** <C,v>
    subsort Qid < Name .        *** creates new names as qid (e.g. 'x 'y 'z 'x0 ...)

    ***
    *** Predicate
    ***
    sort Predicate .        *** p
    sort True .             *** true
    sort False .            *** false
    sort And .              *** p && p
    sort Or .               *** p || p
    sort Not .              *** ! p
    sort LT .               *** E < E
    sort LET .              *** E <= E
    sort GT .               *** E > E
    sort GET .              *** E >= E
    sort EQ .               *** E == E
    sort NE .               *** E != E
    subsorts True False And Or Not LT LET GT GET EQ NE < Predicate .

    ***
    *** Expression
    ***
    sort Expression .       *** E
    sort Sum .              *** E + E
    sort Minus .            *** E - E
    sort Size .             *** |a|
    sort SecretReference .  *** a
    sort Constant .         *** N
    subsort Sum Minus Size SecretReference Constant < Expression .

    ***
    *** Contract
    ***
    sort Contract .         *** C
    sort GuardedContract .  *** D
    sort PutReveal .        *** put x^ & reveal a^ if p
    sort Withdraw .         *** withdraw A
    sort Split .            *** split ( v -> C, v' -> C' ... )
    sort AuthC .            *** A: D
    sort After .            *** after t : D
    subsorts PutReveal Withdraw Split AuthC After < GuardedContract < Contract .
    
    ***
    *** Contract Preconditions
    ***
    sort ContractPrecondition .        *** G
    sort VolDeposit .                  *** A: ?v @x
    sort PerDeposit .                  *** A: !v @x
    sort CommSecret .                  *** A: secret a
    subsorts VolDeposit PerDeposit CommSecret < ContractPrecondition .
    
    ***
    *** Configurations
    ***
    sort Configuration .        *** Gamma
    sort AdvContract .          *** {G}C
    sort ActContract .          *** <C,v>x
    sort Deposit .              *** <A,v>x
    sort Auth .                 *** A[chi] 
    sort ConfSec .              *** {A:a#N}
    sort ConfRev .              *** A:a#N
    subsorts AdvContract ActContract Deposit Auth ConfSec ConfRev < Configuration .

    ***
    *** Authorization
    ***
    sort AuthAction .           *** chi
    sort CommitSec .            *** # |> {G}C
    sort SpendDep .             *** x |> {G}C
    sort TakeBranch .           *** x |> D
    sort Join .                 *** x,y |> <A,v>
    sort Divide .               *** x |> <A,v> <A,v'>
    sort Donate .               *** x |> B
    sort Destroy .              *** x^,i |> y
    subsort CommitSec SpendDep TakeBranch Join Divide Donate Destroy < AuthAction .
endfm

***
*** Views allow reuse maude modules like List{X} and Set{X}
***
view Name from TRIV to BITML-SORTS is
    sort Elt to Name .
endv

view Secret from TRIV to BITML-SORTS is
    sort Elt to Secret .
endv

view Configuration from TRIV to BITML-SORTS is
    sort Elt to Configuration .
endv

view SplitEntry from TRIV to BITML-SORTS is
    sort Elt to SplitEntry .
endv

view Value from TRIV to BITML-SORTS is
    sort Elt to Value .
endv

view Participant from TRIV to BITML-SORTS is
    sort Elt to Participant .
endv

***
*** BitML Syntax
***
fmod BITML-SYNTAX is
    protecting BITML-SORTS .
    protecting SET{Name} .
    protecting SET{Secret} .
    protecting LIST{SplitEntry} .
    protecting LIST{Configuration} .
    protecting LIST{Participant} .
    protecting SET{Participant} .
    protecting SORTABLE-LIST{Nat<} .
    protecting LIST{Value} .

    op P(_) : Qid -> Participant [ctor prec 5] .
    op _BTC : Nat -> Value [ctor prec 5] .                                                  *** n BTC
    op _~>_ : Value Contract -> SplitEntry [ctor prec 5 frozen format (ni d ++ --)] .       *** v' -> C
    op <_,_> : Participant Value -> AnonDeposit [ctor prec 5 frozen format (d d d s d d)] . *** <A,v>
    op <_,_> : Contract Value -> AnonContract [ctor prec 5 frozen format (d d d s d d)] .   *** <C,v>

    ***
    *** Predicates/Expressions
    ***
    op True : -> True [ctor] .
    op False : -> False [ctor] .
    op _||_ : Predicate Predicate -> Or [ctor prec 25 frozen comm] .
    op _&&_ : Predicate Predicate -> And [ctor prec 24 frozen comm] .
    op !_ : Predicate -> Not [ctor prec 23 frozen] .
    op _<_ : Expression Expression -> LT [ctor prec 22 frozen] .
    op _<=_ : Expression Expression -> LET [ctor prec 22 frozen] .
    op _>_ : Expression Expression -> GT [ctor prec 22 frozen] .
    op _>=_ : Expression Expression -> GET [ctor prec 22 frozen] .
    op _==_ : Expression Expression -> NE [ctor prec 22 frozen comm] .
    op _!=_ : Expression Expression -> NE [ctor prec 22 frozen comm] .

    op _+_ : Expression Expression -> Sum [ctor prec 21 frozen comm] .
    op _-_ : Expression Expression -> Minus [ctor prec 21 frozen comm] .
    op |_| : Expression -> Size [ctor prec 21 frozen] .
    op ref(_) : Secret -> SecretReference [ctor prec 21 frozen] .
    op const(_) : Int -> Constant [ctor prec 21 frozen] .

    ***
    *** Contract 
    ***
    op 0 : -> Contract [ctor] .                                                                                     *** [contr.id]
    op put_reveal_if_._ : Set{Name} Set{Secret} Predicate Contract -> PutReveal [ctor prec 25 frozen] .             *** [contr.put-reveal]
    op withdraw_ : Participant -> Withdraw [ctor prec 25 frozen] .                                                  *** [contr.withdraw]
    op _:_ : Set{Participant} GuardedContract -> AuthC [ctor prec 25 frozen] .                                      *** [contr.authorization]
    op after_:_ : Nat GuardedContract -> After [ctor prec 25 frozen] .                                              *** [contr.after]
    op split(_) : List{SplitEntry} -> Split [ctor prec 25 frozen format (d d ++i n--i d)] .                         *** [contr.split]
    op _+_ : GuardedContract GuardedContract -> GuardedContract [comm assoc ctor id: 0 frozen format (d d d d)] .   *** [contr.sum]

    ***
    *** Contract Preconditions
    ***
    op 0 : -> ContractPrecondition [ctor] .                                                                *** [contr-pre.id]
    op _?_@_ : Participant Value Name -> VolDeposit [ctor prec 25 frozen] .                                *** [contr-pre.vol-deposit]
    op _!_@_ : Participant Value Name -> PerDeposit [ctor prec 25 frozen] .                                *** [contr-pre.perm-deposit]
    op _secret_ : Participant Secret -> CommSecret [ctor prec 25 frozen] .                                 *** [contr-pre.commit-secret]
    op _|_ : ContractPrecondition ContractPrecondition -> ContractPrecondition [comm assoc id: 0 frozen] . *** [contr-pre.paral]

    ***
    *** Configurations
    ***
    op 0 : -> Configuration [ctor] .                                                                            *** [conf.id]
    op {_}_ : ContractPrecondition Contract -> AdvContract [ctor prec 35 frozen] .                              *** [conf.contract-advertised]
    op __ : AnonContract Name -> ActContract [ctor prec 15 frozen format (d s d)] .                             *** [conf.active-contract]
    op __ : AnonDeposit Name -> Deposit [ctor prec 15 frozen format (d s d)] .                                  *** [conf.deposit]
    op _[_] : Participant AuthAction -> Auth [ctor prec 35 frozen] .                                            *** [conf.authorization]
    op {_:_#_} : Participant Secret Nat -> ConfSec [ctor prec 35 frozen] .                                      *** [conf.committed-secret]
    op _:_#_ : Participant Secret Nat -> ConfRev [ctor prec 35 frozen] .                                        *** [conf.revealed-secret]
    op _|_ : Configuration Configuration -> Configuration [comm assoc ctor id: 0 frozen] .                      *** [conf.parallel]

    ***
    *** Authorization
    ***
    op #|>_ : AdvContract -> CommitSec [ctor frozen] .                  *** [auth.commit-secret]
    op _|>_ : Name AdvContract -> SpendDep [ctor frozen] .              *** [auth.spend-deposit]
    op _|>_ : Name GuardedContract -> TakeBranch [ctor frozen] .        *** [auth.take-branch]
    op __|>_ : Name Name AnonDeposit -> Join [ctor frozen] .            *** [auth.join]
    op _|>__ : Name AnonDeposit AnonDeposit -> Divide [ctor frozen] .   *** [auth.divide]
    op _|>_ : Name Participant -> Donate [ctor frozen] .                *** [auth.donate]
    op _|># : Name -> Destroy [ctor frozen] .                           *** [auth.destroy]
endfm


***
*** Define structural equivalences
***
fmod BITML-STREQ is
    protecting BITML-SYNTAX .
    
    var x^ : Set{Name} .
    var a^ : Set{Secret} .
    var C : Contract .
    var p p' : Predicate .
    vars A B : Participant .
    vars A^ B^ : Set{Participant} .
    var D : GuardedContract .
    vars t t' : Nat .
    vars n m n' m' : Nat .
    vars E E' E'' : Expression .

    op tau ._ : Contract -> PutReveal [prec 25 frozen] .
    op put_._ : Set{Name} Contract -> PutReveal [prec 25 frozen] .
    op put_if_._ : Set{Name} Predicate Contract -> PutReveal [prec 25 frozen] .
    op reveal_._ : Set{Secret} Contract -> PutReveal [prec 25 frozen] .
    op reveal_if_._ : Set{Secret} Predicate Contract -> PutReveal [prec 25 frozen] .
    op put_reveal_._ : Set{Name} Set{Secret} Contract -> PutReveal [prec 25 frozen] .

    eq tau . C = put empty reveal empty if True . C .
    eq put x^ . C = put x^ reveal empty if True . C .
    eq put x^ if p . C = put x^ reveal empty if p . C .
    eq reveal a^ . C = put empty reveal a^ if True . C .
    eq reveal a^ if p . C = put empty reveal a^ if p . C .
    eq put x^ reveal a^ . C = put x^ reveal a^ if True . C .
    
    eq empty : D = D .
    eq A : A^ : D = (A, A^) : D .
    eq A^ : A : D = (A^, A) : D .

    eq after 0 : D = D .
    eq after t : after t' : D = after max(t,t') : D .

    eq after t : A : D = A : after t : D .
    *** TODO: add more...
endfm

***
*** Get names in a Configuration
***
fmod BITML-FREENAME is

    protecting BITML-STREQ .
    vars d d' : AnonDeposit .
    vars x y z : Name .
    vars A B : Participant .
    vars v v' : Value .
    vars auth : AuthAction .
    vars S S' P P' : Configuration .
    var s : Secret .
    var sL : Set{Secret} .
    var n n' t : Nat .
    var dL : Set{Name} .
    var acc : Set{Name} .
    var C C' : Contract .
    var sel : List{SplitEntry} .
    var D D' : GuardedContract .
    var cp : ContractPrecondition .
    var advC : AdvContract .
    var p : Predicate .
    var str : String .
    var tail : List{Configuration} .

    op names in _ : ContractPrecondition -> Set{Name} [memo] .
    op names in _ : Contract -> Set{Name} [memo] .
    op names in _ : Configuration -> Set{Name} [memo] .
    op names in _ : AuthAction -> Set{Name} [memo] .

    eq names in C:Contract = empty [owise] .
    eq names in C:ContractPrecondition = empty [owise] .
    eq names in S:Configuration = empty [owise] .
    eq names in A:AuthAction = empty [owise] .

    ***
    *** Contract 
    ***
    eq names in (put dL reveal sL if p . C + C') = dL, (names in C), (names in C') .                    *** [contr.put-reveal]
    eq names in (A : D + C') = names in D, (names in C') .                                              *** [contr.authorization]
    eq names in (after t : D + C') = names in D, (names in C') .                                        *** [contr.after]
    eq names in (split( nil ) + C') = (names in C') .                                                   *** [contr.split]
    eq names in (split( (v ~> C) sel ) + C') = (names in C), (names in (split(sel))), (names in C') .   *** [contr.split]

    ***
    *** Contract Preconditions
    ***
    eq names in (A ? v @ y | cp) = y, (names in cp) .   *** [contr-pre.vol-deposit]
    eq names in (A ! v @ y | cp) = y, (names in cp) .   *** [contr-pre.perm-deposit]

    ***
    *** Configurations
    ***
    eq names in ({cp}C | S) = (names in cp), (names in C), (names in S) .                             *** [conf.contract-advertised]
    eq names in (< C , v > y | S) = y, (names in C), (names in S) .                                   *** [conf.active-contract]
    eq names in (< A , v > y | S) = y, (names in S) .                                                 *** [conf.deposit]
    eq names in (A[auth] | S) = names in auth, (names in S) .                                         *** [conf.authorization]

    ***
    *** Authorization
    ***
    eq names in (#|> advC) = (names in advC) .      *** [auth.commit-secret]
    eq names in (y |> advC) = y, (names in advC) .  *** [auth.spend-deposit]
    eq names in (y |> D) = y, (names in D) .        *** [auth.take-branch]
    eq names in (y z |> d) = y, z .                 *** [auth.join]
    eq names in (y |> d d') = y .                   *** [auth.divide]
    eq names in (y |> B) = y .                      *** [auth.donate]
    eq names in (x |>#) = x .                       *** [auth.destroy]
endfm

***
*** Get participants in a Configuration
***
fmod BITML-PARTICIPANTS is

    protecting BITML-STREQ .
    vars d d' : AnonDeposit .
    vars x y z : Name .
    vars A B : Participant .
    vars v v' : Value .
    vars auth : AuthAction .
    vars S S' P P' : Configuration .
    var s : Secret .
    var sL : Set{Secret} .
    var n n' t N : Nat .
    var dL : Set{Name} .
    var acc : Set{Name} .
    var C C' : Contract .
    var sel : List{SplitEntry} .
    var D D' : GuardedContract .
    var cp : ContractPrecondition .
    var advC : AdvContract .
    var p : Predicate .
    var str : String .
    var tail : List{Configuration} .
    var a : Secret .

    op participants in _ : ContractPrecondition -> Set{Participant} [memo] .
    op participants in _ : Contract -> Set{Participant} [memo] .
    op participants in _ : Configuration -> Set{Participant} [memo] .
    op participants in _ : AuthAction -> Set{Participant} [memo] .

    eq participants in C:Contract = empty [owise] .
    eq participants in C:ContractPrecondition = empty [owise] .
    eq participants in S:Configuration = empty [owise] .
    eq participants in A:AuthAction = empty [owise] .

    ***
    *** Contract 
    ***
    eq participants in (put dL reveal sL if p . C + C') = (participants in C), (participants in C') .                               *** [contr.put-reveal]    
    eq participants in (withdraw A + C) = A, (participants in C) .                                                                  *** [contr.withdraw]
    eq participants in (A : D + C') = A, participants in D, (participants in C') .                                                  *** [contr.authorization]
    eq participants in (after t : D + C') = participants in D, (participants in C') .                                               *** [contr.after]
    eq participants in (split( nil ) + C') = (participants in C') .                                                                 *** [contr.split]
    eq participants in (split( (v ~> C) sel ) + C') = (participants in C), (participants in (split(sel))), (participants in C') .   *** [contr.split]

    ***
    *** Contract Preconditions
    ***
    eq participants in (A ? v @ y | cp) = A, (participants in cp) .   *** [contr-pre.vol-deposit]
    eq participants in (A ! v @ y | cp) = A, (participants in cp) .   *** [contr-pre.perm-deposit]
    eq participants in (A secret a | cp) = A, (participants in cp) .  *** [contr-pre.commit-secret]

    ***
    *** Configurations
    ***
    eq participants in ({cp}C | S) = (participants in cp), (participants in C), (participants in S) .   *** [conf.contract-advertised]
    eq participants in (< C , v > y | S) = (participants in C), (participants in S) .                   *** [conf.active-contract]
    eq participants in (< A , v > y | S) = A, (participants in S) .                                     *** [conf.deposit]
    eq participants in (A[auth] | S) = A, participants in auth, (participants in S) .                   *** [conf.authorization]
    eq participants in ({ A : a # N } | S) = A, (participants in S) .                                   *** [conf.committed-secret]
    eq participants in ( A : a # N | S) = A, (participants in S) .                                      *** [conf.revealed-secret]

    ***
    *** Authorization
    ***
    eq participants in (#|> advC) = (participants in advC) .    *** [auth.commit-secret]
    eq participants in (y |> advC) = (participants in advC) .   *** [auth.spend-deposit]
    eq participants in (y |> D) = (participants in D) .         *** [auth.take-branch]
    eq participants in (y |> B) = B .                           *** [auth.donate]
endfm


fmod BITML-UTILS is

    protecting BITML-STREQ .
    protecting BITML-FREENAME .
    protecting BITML-PARTICIPANTS .
    protecting SORTABLE-LIST-AND-SET{Nat<} .

    var v : Value .
    var x y x' y' x'' y'' : Name .
    var tail : List{SplitEntry} .
    var e : SplitEntry .
    var C C' : Contract .
    vars D D' : GuardedContract .
    var S S' S'' S''' : Configuration .
    var n n' N : Nat .
    var a : Secret .
    vars x^ y^ : Set{Name} .
    vars X0 : Set{Name} .
    vars a^ : Set{Secret} .
    vars v^ : List{Value} .
    vars A B : Participant .
    vars A^ B^ : Set{Participant} .
    vars N^ : List{Nat<} .
    var accConf : Configuration .    
    var n^ : Set{Nat<} .
    var p : Predicate .
    var sel : List{SplitEntry} .
 
    ***
    *** return a fresh Name
    ***
    op fresh(_) : Set{Name} -> Set{Name} [memo] .
    op fresh(_,_) : Set{Name} Nat -> Set{Name} [memo] .    
    op $fresh(_,_,_,_) : Set{Name} Nat Nat Set{Name} -> Set{Name} [memo] .

    eq fresh(x^) = fresh(x^,1) .
    eq fresh(x^,n) = $fresh(x^,n,0,empty) .
    *** generic implementation
    ceq $fresh(x^,n,n',y^) =
        if n <= 0
        then y^
        else if  x in x^        
             then $fresh(x^,n,(n' + 1),y^)
             else $fresh(x^,(n + -1),(n' + 1),(y^, x))
             fi 
        fi 
    if x := qid("x" + str(n')).
    
    ***
    *** convert natural to string (use CONVERSION module)
    ***
    op str(_) : Nat -> String [memo] .
    eq str(n) = string(n, 10) .
    
    
    ***
    *** Take a list of split entries and names to create a configuration of parallel contracts
    *** es. 
    ***     || (v ~> C v' ~> C' v'' ~> C'' ) (x x' x'') == <C,v> x | <C',v'> x' | <C'',v''> x''
    ***
    op ||__ : List{SplitEntry} Set{Name} -> Configuration [memo] .
    eq || (v ~> C nil) (x, empty) = < C, v > x .
    ceq || (v ~> C tail) (x, x^) = < C, v > x | ||(tail)(x^) if size(tail) == | x^ | .
    
    *** Sum for values
    op _+_ : Value Value -> Value [memo] .
    eq n BTC + n' BTC = (n + n') BTC .
    
    ***
    *** Return the total amount value of a list of split entries
    ***
    op value(_) : List{SplitEntry} -> Value [memo] .
    op $value(_,_) : List{SplitEntry} Nat -> Value [memo] .
    eq value(sel) = $value(sel,0) .
    eq $value(nil,n) = 0 BTC .
    eq $value(n BTC ~> C tail,n') = $value(tail, n + n') .

    ***
    *** Option
    ***     None
    ***     Some(Any)
    ***
    sort Option None Some .
    subsorts None Some < Option .
    op None : -> None [ctor] .
    op Some_ : Universal -> Some [ctor poly(1)] .


    ***
    *** Try
    ***     Success(Any)
    ***     Failure(String)
    ***
    sort Try Success Failure .
    subsorts Success Failure < Try .
    op Success : Universal -> Success [ctor poly(1)] .
    op Failure : String -> Failure [ctor] .

    ***
    *** Convert Some(Configuration) to Configuration
    ***
    op toConf_ : Some -> Configuration .
    eq toConf Some S = S .

    ***
    *** Given a list of names x^ and S, split the deposits from S.
    *** Return a Some(D R) with D == all deposits in S and R == S \ D,
    *** or None if some deposit is not found.
    ***
    op deposits__ : Set{Name} Configuration -> Option [memo] .
    eq deposits x^ S = depositsTR x^ S 0 .
    op depositsTR___ : Set{Name} Configuration Configuration -> Option [memo] .
    eq depositsTR empty S accConf = Some (accConf S) .    *** base case
    eq depositsTR (x, x^) ((< A , v > x) | S) accConf = depositsTR x^ S (accConf | < A , v > x) .
    eq depositsTR x^ S accConf = None [owise].

    ***
    *** Given a list of secrets a^ and S, fetch all the secrets in S.
    *** Return a Some(S') with S' == all secrets in S,
    *** or None if some secret is not found.
    ***
    op secrets__ : Set{Secret} Configuration -> Option [memo] .
    eq secrets a^ S = $secrets a^ S 0 .
    op $secrets___ : Set{Secret} Configuration Configuration -> Option [memo] .
    eq $secrets empty S accConf = Some accConf .    *** base case
    eq $secrets (a, a^) ((A : a # N) | S) accConf = $secrets a^ S (accConf | A : a # N) .
    eq $secrets a^ S accConf = None [owise].


    ***
    *** Given a set of participants A^ and a guarded contract D,
    *** search for all A [ y |> D ] within a configuration S.
    *** Return a Some(S' R) with S' == all the authorization A [ y |> D ] and R == S \ S'
    *** or None if some authorization is not found.
    ***
    op searchAuth____ : Set{Participant} GuardedContract Name Configuration -> Option [memo] .
    eq searchAuth A^ D y S = $searchAuth A^ D y S 0 .
    op $searchAuth_____ : Set{Participant} GuardedContract Name Configuration Configuration -> Option [memo] .
    eq $searchAuth empty D y S accConf = Some (accConf S) .    *** base case
    eq $searchAuth (A, A^) D y (A [ y |> D ] | S) accConf = $searchAuth A^ D y S (accConf | A [ y |> D ]) .
    eq $searchAuth A^ D y S accConf = None [owise] .

    ***
    *** Given a participant A and a deposit name,
    *** search for destroy authorization A [ x |># ] within a configuration S.
    *** Return a Some(S' R) with S' == the authorization A [ x |># ] and R == S \ S'
    *** or None if the authorization is not found.
    ***
    op searchAuthDestroy___ : Participant Name Configuration -> Option [memo] .
    eq searchAuthDestroy A x (A [ x |># ] | S) = Some ((A [ x |># ]) S) .
    eq searchAuthDestroy A x S = None [owise] .

    ***
    *** Return a ordered set of absolute times
    ***
    op ticks : Configuration -> List{Nat<} [memo] .
    eq ticks(S) = ticks(S, names in S) .

    op ticks : Configuration Set{Name} -> List{Nat<} [memo] .
    eq ticks(S, X0) = makeList($ticks(S, X0, empty)) .

    *** tail-recursion on Configuration
    op $ticks : Configuration Set{Name} Set{Nat<} -> Set{Nat<} [memo] .
    eq $ticks(< C, v > x, X0, n^) = if x in X0 then $ticks(C, n^) else n^ fi .
    ceq $ticks(S | S', X0, n^) = $ticks(S, X0, n^), $ticks(S', X0, n^) if S =/= 0 /\ S' =/= 0 .
    eq $ticks(S, X0, n^) = n^ [owise] .

    *** tail-recursion on Contracts
    op $ticks : Contract Set{Nat<} -> Set{Nat<} [memo] .
    eq $ticks(put x^ reveal a^ if p . C, n^) = $ticks(C, n^) .
    eq $ticks(withdraw A, n^) = n^ .
    eq $ticks(A^ : D, n^) = $ticks(D, n^) .
    eq $ticks(after n : D, n^) = $ticks(D, (n, n^)) .
    eq $ticks(split(nil),n^) = n^ .
    eq $ticks(split( (v ~> C) sel ), n^) = $ticks(split(sel), n^), $ticks(C, n^) .
    ceq $ticks(C + C', n^) = $ticks(C, n^), $ticks(C', n^) if C =/= 0 /\ C' =/= 0 .
    eq $ticks(C, n^) = n^ [owise] .
endfm

fmod BITML-PREDICATE-SAT is
    protecting BITML-UTILS .
    protecting SATISFACTION .
    subsort Configuration < State .

    op predicate_ : Predicate -> Prop .

    var b b' : Bool .
    var P P' : Predicate .
    var S S' : Configuration .
    var a : Secret .
    var n m : Nat .
    var N : Nat .
    var A : Participant .
    vars E E' E'' : Expression .

    eq S |= predicate P = $eval P [ S ] == Success(true) .
    ceq S | S' |= predicate P = S |= predicate P or-else S' |= predicate P if S =/= 0 /\ S' =/= 0 .
    eq S |= predicate P = false [owise] .

    op toExp_ : Bool -> Predicate [prec 65] .
    eq toExp true = True .
    eq toExp false = False .

    op $eval_[_] : Predicate Configuration -> Try .
    ceq $eval P && P' [ S ] = Success(b and b') if Success(b) := $eval P [ S ] /\ Success(b') := $eval P' [ S ] .
    ceq $eval P || P' [ S ] = Success(b or b') if Success(b) := $eval P [ S ] /\ Success(b') := $eval P' [ S ] .
    ceq $eval ! P [ S ] = Success(not b) if Success(b) := $eval P [ S ] .
    ceq $eval E != E' [ S ] = Success(n =/= m) if Success(n) := $eval E [ S ] /\ Success(m) := $eval E' [ S ] .
    ceq $eval E == E' [ S ] = Success(n == m) if Success(n) := $eval E [ S ] /\ Success(m) := $eval E' [ S ] .
    ceq $eval E < E' [ S ] = Success(n < m) if Success(n) := $eval E [ S ] /\ Success(m) := $eval E' [ S ] .
    ceq $eval E <= E' [ S ] = Success(n <= m) if Success(n) := $eval E [ S ] /\ Success(m) := $eval E' [ S ] .
    ceq $eval E > E' [ S ] = Success(n > m) if Success(n) := $eval E [ S ] /\ Success(m) := $eval E' [ S ] .
    ceq $eval E >= E' [ S ] = Success(n >= m) if Success(n) := $eval E [ S ] /\ Success(m) := $eval E' [ S ] .
    eq $eval True [ S ] = Success(true) .
    eq $eval False [ S ] = Success(false) .
    
    op $eval_[_] : Expression Configuration -> Try .
    eq $eval const(n) [ S ] = Success(n) .
    eq $eval | ref(a) | [ (A : a # N) | S ] = Success(N) .
    ceq $eval | E | [ S ] = Success(rat( ceiling( (log(float(n))) / (log(float(2))) / 7.0 ) ) ) if Success(n) := $eval E [ S ] .
    ceq $eval E + E' [ S ] = Success(n + m) if Success(n) := $eval E [ S ] /\ Success(m) := $eval E' [ S ] .
    ceq $eval E - E' [ S ] = Success(n + - m) if Success(n) := $eval E [ S ] /\ Success(m) := $eval E' [ S ] .

    eq $eval P [ S ] = Failure("Unable to evaluate the predicate") [owise] .
    eq $eval E [ S ] = Failure("Unable to evaluate the expression") [owise] .

    ***
    *** Simplifications
    ***
    eq ! True = False .
    eq ! False = True .
    eq True || P = True .
    eq False && P = False .
    eq False || P = P .
    eq True && P = P .
    eq const(n) + const(m) = const(n + m) .
    eq const(n) - const(m) = const(n + (- m)) .
    eq const(n) < const(m) = toExp  n < m .
    eq const(n) <= const(m) = toExp n <= m .
    eq const(n) > const(m) = toExp n > m .
    eq const(n) >= const(m) = toExp n >= m .
    eq const(n) == const(m) = toExp n == m .
    eq const(n) != const(m) = toExp n =/= m .
    eq | const(n) | = const( rat( ceiling( (log(float(n))) / (log(float(2))) / 7.0 ) ) ) .

    ***
    *** Extra operations
    ***
    op _<=_<=_ : Expression Expression Expression -> Predicate .
    eq E <= E' <= E'' = E <= E' && E' <= E'' .

    op _<_<_ : Expression Expression Expression -> Predicate .
    eq E < E' < E'' = E < E' && E' < E'' .

    op _<=_<_ : Expression Expression Expression -> Predicate .
    eq E <= E' < E'' = E <= E' && E' < E'' .

    op _<_<=_ : Expression Expression Expression -> Predicate .
    eq E < E' <= E'' = E < E' && E' <= E'' .
endfm

mod BITML-SEM is
    extending BITML-SYNTAX .
    protecting BITML-STREQ .
    protecting BITML-FREENAME .
    protecting BITML-UTILS .
    protecting BITML-PREDICATE-SAT .
    
    var A B A' B' A'' B'' Any : Participant .
    var Part : Set{Participant} .
    var C C' : Contract .
    var D D' : GuardedContract .
    vars v v' v'' v''' : Value .
    vars x y z x' y' z' x'' y'' z'' : Name .
    vars x^ y^ : Set{Name} .
    vars a^ : Set{Secret} .
    vars v^ : List{Value} .
    vars A^ B^ : Set{Participant} .
    vars n^ N^ : List{Nat<} .
    vars t^ t'^ : List{Nat<} .
    vars S S' S'' S''' P P' : Configuration .
    vars a a' : Secret .
    vars n n' N t t' : Nat .
    vars s s' : Secret .
    vars s^ : Set{Secret} .
    vars l l' : Label .
    vars fv fv' : Set{Name} .
    var splitEntries : List{SplitEntry} .
    vars p p' : Predicate .
    vars putDeps putSecs : Option .
    
    sort SemConfiguration .
    sort LSemConfiguration .
    subsort SemConfiguration < LSemConfiguration .

    sort Context .
    
    op [_|_|_|_] : Nat List{Nat<} Set{Name} Set{Participant} -> Context [ctor frozen] .
    op Adv : -> Participant .
    
    op __ : Context Configuration -> SemConfiguration [ctor frozen] .

    op {_}_ : Label SemConfiguration -> LSemConfiguration [ctor frozen] .
    
    op toSemConf_ : Configuration -> SemConfiguration [prec 50] .
    eq toSemConf S = [ 0 | ticks(S) | (names in S) | (participants in S) ] S .

    *** Labels
    sort Label .
    
    op _authorize-destroy-of_ : Participant Name -> Label [ctor frozen] .
    op _destroy_ : Participant Name -> Label [ctor frozen] .
    op _split_ : Participant Name -> Label [ctor frozen] .
    op _put(_,_,_) : Participant Set{Name} Set{Secret} Name -> Label [ctor frozen] .
    op _reveal_ : Participant Secret  -> Label [ctor frozen] .
    op _ do withdraw _ _ from _ : Participant Participant Value Name -> Label [ctor frozen] .
    op _authorize_in_ : Participant Contract Name -> Label [ctor frozen] .

    op delta_ : Nat -> Label [ctor frozen] .

    *** cv(l) : get the name from a label l
    op cv(_) : Label -> Option .
    eq cv(Any do withdraw A v from x) = Some x .
    eq cv(Any split(x)) = Some x .
    eq cv(Any put(x^,a^,y)) = Some y .
    eq cv(l) = None [owise].
    
    op part(_) : Label -> Participant .
    eq part(Any authorize-destroy-of x) = Any .
    eq part(Any destroy x) = Any .
    eq part(Any split(x)) = Any .
    eq part(Any put(x^,a^,y)) = Any .
    eq part(Any do withdraw A v from x) = Any .
    eq part(Any authorize D in x) = Any .
    

    *** strategies
    op strategy : SemConfiguration Label -> Bool [memo] .
    eq strategy(S:SemConfiguration, l) = true [owise] .         *** default: all moves are enabled

    *** Allow progression of labelled configuration (timed)
    
    crl [Rifl] : {l} [t | t^ | fv | Part] S => {l'} [t' | t'^ | fv' | Part] S' 
        if  [t | t^ | fv | Part] S => {l'} [t' | t'^ | fv' | Part] S' .

    rl [Finalize] : {l} [t | t^ | fv | Part] S => [t | t^ | fv | Part] S .

    ***
    *** [t | t^ | fv] S => {l} [t' | t'^ | fv'] S'    
    ***
    crl [Dep-AuthDestroy] : [t | t^ | fv | Part] < A , v > x | S => { A authorize-destroy-of x } [t | t^ | fv | Part] < A , v > x | A [ x |># ] | S
                    if  strategy([t | t^ | fv | Part] < A , v > x | S, A authorize-destroy-of x) /\
                        None := (searchAuthDestroy A x S) .  *** check that A has not already authorized to destroy x

    crl [Dep-Destroy] : [t | t^ | fv | Any, Part] < A , v > x | A [ x |># ] | S => { Any destroy x } [t | t^ | fv | Any, Part] S 
                    if  strategy([t | t^ | fv | Any, Part] < A , v > x | A [ x |># ] | S, Any destroy x) .

    crl [C-Split] : [t | t^ | fv | Any, Part] < (split (splitEntries) ) + C, v > y | S => { Any split(y) } [t | t^ | fv, fv' | Any, Part] ((|| splitEntries fv') | S )
                    if  strategy([t | t^ | fv | Any, Part] < (split (splitEntries) ) + C, v > y | S, Any split(y)) /\
                        fv' := fresh(fv,size(splitEntries)) .

    crl [C-PutReveal] : [t | t^ | fv | Any, Part] < (put x^ reveal a^ if p . C) + C', v > y | S => { Any put(x^,a^,y) } [t | t^ | fv, z | Any, Part] ( < C, v > z | S'')
                    if  strategy([t | t^ | fv | Any, Part] < (put x^ reveal a^ if p . C) + C', v > y | S, Any put(x^,a^,y)) /\
                        z := fresh(fv) /\ 
                        Some (S' S'') := (deposits x^ S) /\ *** fetch all deposits x^ in S (S' are deposits in S, S'' == S \ S')
                        Some S''' := (secrets a^ S'') /\    *** fetch all secrets a^ in S
                        S''' |= predicate p .

    crl [C-AuthRev] : [t | t^ | fv | Part] {A : a # N} | S => { A reveal a } [t | t^ | fv | Part] (A : a # N | S) 
                    if  strategy([t | t^ | fv | Part] {A : a # N} | S, A reveal a) .

    crl [C-Withdraw] : [t | t^ | fv | Any, Part] < withdraw A + C, v > y | S => { Any do withdraw A v from y } [t | t^ | fv, z | Any, Part] (< A, v > z | S)
                    if  strategy([t | t^ | fv | Any, Part] < withdraw A + C, v > y | S, Any do withdraw A v from y) /\
                        z := fresh(fv) .

    crl [C-AuthControl] : [t | t^ | fv | Part] < (A, A^) : D + C, v > y | S => { A authorize D in y } [t | t^ | fv | Part] (< (A, A^) : D, v > y | A [ y |> (A, A^) : D ] | S)
                    if  strategy([t | t^ | fv | Part] < (A, A^) : D, v > y | S, A authorize D in y) /\
                        None := (searchAuth A ((A, A^) : D) y S) .  *** check that branch D is not already authorized by A

    crl [C-Control1] : [t | t^ | fv | Part] < A^ : after t' : D + C, v > y | S => {l'} [t | t^ | fv' | Part] S'
                    if  t >= t' /\                                                      *** timelocks satisfied
                        Some (S'' S''') := (searchAuth A^ (A^ : after t' : D) y S) /\   *** S'' are authorizations, S''' ==  S \ S''
                        [t | t^ | fv | Part] < D, v > y | S''' => {l'} [t | t^ | fv' | Part] S' /\
                        Some y == cv(l') .                                              *** withdraw/split/put-reveal

    crl [C-Control2] : [t | t^ | fv | Part] < after t' : D + C, v > y | S => {l'} [t | t^ | fv' | Part] S'
                    if  t >= t' /\                                                      *** timelocks satisfied
                        [t | t^ | fv | Part] < D, v > y | S => {l'} [t | t^ | fv' | Part] S' /\       *** D progresses
                        Some y == cv(l') .                                              *** withdraw/split/put-reveal

    crl [C-Control3] : [t | t^ | fv | Part] < A^ : D + C, v > y | S => {l'} [t | t^ | fv' | Part] S'
                    if  Some (S'' S''') := (searchAuth A^ (A^ : D) y S) /\              *** S'' are authorizations, S''' == S \ S''
                        [t | t^ | fv | Part] < D, v > y | S''' => {l'} [t | t^ | fv' | Part] S' /\    *** D progresses
                        Some y == cv(l') .                                              *** withdraw/split/put-reveal

    crl [Delay] : [t | t^ | fv | Part] S => {delta (t' + - t)} [t' | t'^ | fv | Part] S 
                    if t^ =/= nil /\ t' := head(t^) /\ t'^ := tail(t^) .

endm

mod BITML is
    protecting BITML-SEM .
endm

***
*** Strategies
***
smod BITML-STRAT is
    protecting BITML .
    
    strat default @ SemConfiguration .
    strat all\delay @ SemConfiguration .
    strat bitml-1step @ SemConfiguration .
    strat bitml @ SemConfiguration .
    
    *** default Maude strategy
    sd default := all ! .
    sd all\delay := Rifl{bitml-1step} or-else ( 
        Dep-AuthDestroy 
      | Dep-Destroy 
      | C-Split 
      | C-PutReveal 
      | C-AuthRev 
      | C-Withdraw 
      | C-AuthControl 
      | C-Control1{all\delay} 
      | C-Control2{all\delay} 
      | C-Control3{all\delay} ) .

    sd bitml-1step := all\delay or-else Delay .
    sd bitml := bitml-1step ! ; Finalize .

    *** Examples
    *** srew [1] in BITML-STRAT : S(WIN') using bitml ! .
    *** srew in BITML-STRAT :  toSemConf < after 10 : withdraw A, 10 BTC > 'x using bitml ! .
endsm

***
*** Model checking
***

mod BITML-PREDS is
    protecting BITML .    
    protecting SATISFACTION .
    including LTL-SIMPLIFIER .

    subsort LSemConfiguration < State .
    op contract-free : -> Prop .

    var C : Contract .
    var v : Value .
    var x : Name .
    var S : Configuration .
    var t : Nat .
    var t^ : List{Nat<} .
    var fv : Set{Name} .
    var l : Label .
    var Part : Set{Participant} .

    eq < C, v > x | S |= contract-free = false .
    eq [t | t^ | fv | Part] S |= contract-free = S |= contract-free .
    eq {l} [t | t^ | fv | Part] S |= contract-free = S |= contract-free .
    eq S:Configuration |= contract-free = true [owise] .
    eq S:SemConfiguration |= contract-free = true [owise] .
    eq S:LSemConfiguration |= contract-free = true [owise] .
endm

smod BITML-CHECK is
    protecting BITML-STRAT .
    protecting BITML-PREDS .
    *** Model checking w/o strategies
    ***including MODEL-CHECKER .
    *** Model checking w strategies
    including STRATEGY-MODEL-CHECKER .
endsm


*** *** *** *** *** *** *** *** *** *** *** *** *** *** *** *** *** *** *** *** *** *** *** *** *** *** *** *** *** ***
*** *** *** *** *** *** *** *** *** *** *** *** *** *** *** *** *** *** *** *** *** *** *** *** *** *** *** *** *** ***
*** *** *** *** *** *** *** *** *** *** *** *** *** *** *** *** *** *** *** *** *** *** *** *** *** *** *** *** *** ***
*** *** *** *** *** *** *** *** *** *** *** *** *** *** *** *** *** *** *** *** *** *** *** *** *** *** *** *** *** ***
*** *** *** *** *** *** *** *** *** *** *** *** *** *** *** *** *** *** *** *** *** *** *** *** *** *** *** *** *** ***
*** *** *** *** *** *** *** *** *** *** *** *** *** *** *** *** *** *** *** *** *** *** *** *** *** *** *** *** *** ***


mod BITML-TEST is  
    protecting BITML .
    ops A B A' B' : -> Participant .
    ops x x' x'' : -> Name .
    ops y y' y'' : -> Name .
    ops z z' z'' : -> Name .
    ops v v' v'' : -> Value .
    ops a a' a'' : -> Secret .
    ops b b' b'' : -> Secret .
    ops x^ y^ z^ : -> Set{Name} . 
    ops v^ : -> List{Value} . 
    ops a^ b^ : -> Set{Secret} . 
    ops n n' N N' t t' : -> Nat .
    ops p p' p'' : -> Predicate .
    ops C C' C'' : -> Contract .
    ops D D' D'' : -> GuardedContract .
    ops l l' l'' : -> Label .
    ops S S' : -> Configuration .
endm

***
*** Example 1.0
***
***     rewrite in Example-1.0 : S .
***
mod Example-1.0 is
    protecting BITML .

    op A : -> Participant .
    op v : -> Value .
    op x : -> Name .
    op S : -> SemConfiguration .

    *** deposit
    eq S = toSemConf < A, v > x .

    *** strategy
    ***     A does not authorize to destroy the deposit x
    eq strategy(S:SemConfiguration, A authorize-destroy-of x) = false .
endm

***
*** Example 1.1
***
***     rewrite in Example-1.1 : S .
***
mod Example-1.1 is
    protecting BITML .

    ops A B : -> Participant .
    ops v v' : -> Value .
    ops x x' y y' : -> Name .
    op S : -> SemConfiguration .

    *** 2 deposits
    eq S = toSemConf < A, v > x | < A, v > x' | < B, v' > y | < B, v' > y' .

    *** strategy
    ***     A does not authorize to destroy any deposit, B does
    *** result
    ***     only B's deposits will be destroyed
    eq strategy(S:SemConfiguration, A authorize-destroy-of x:Name) = false .
endm

***
*** Example 1.2
***
***     rewrite in Example-1.2 : S .
***
mod Example-1.2 is
    protecting BITML .

    op A : -> Participant .
    op v : -> Value .
    op x : -> Name .
    op S : -> SemConfiguration .

    *** deposit
    eq S = toSemConf < A, v > x .

    *** strategy
    ***     block everything
    eq strategy(S:SemConfiguration, l:Label) = false [owise] .
endm

***
*** Example 2.0
***
***     rewrite in Example-2.0 : S .
***
mod Example-2.0 is
    protecting BITML .

    op A : -> Participant .
    op v : -> Value .
    op x : -> Name .
    op S : -> SemConfiguration .

    *** deposit
    eq S = [0 | 0 4 | x | A] < A, v > x .

    *** strategy
    ***     A does not authorize to destroy the deposit x
    eq strategy([t:Nat | t^:List{Nat<} | fv:Set{Name} | Part:Set{Participant}] S:Configuration, A authorize-destroy-of x) = 
        t:Nat >= 5 .
endm

***
*** Example Example-LOTTERY
***
***     rewrite in Example-LOTTERY : S(WIN) .
***
mod Example-LOTTERY is
    protecting BITML .

    ops A B : -> Participant .
    op v : -> Value .
    ops a b : -> Secret .
    ops t t' N M : -> Nat .
    op LOTTERY : -> SemConfiguration .
    op LIQUID-LOTTERY : -> SemConfiguration .
    op S : Contract -> SemConfiguration .
    ops WIN WIN' : -> Contract .

    eq t = 10 .
    eq t' = 15 .
    eq N = 1 .
    eq M = 1 .

    *** lottery
    
    eq LOTTERY = S(WIN) .
    eq LIQUID-LOTTERY = S(WIN') .
    
    eq S(WIN:Contract) = 
        toSemConf
	    < split(
	        2 BTC ~> ( reveal b if const(0) <= | ref(b) | <= const(1) . withdraw B + after t : withdraw A )
	        2 BTC ~> ( reveal a . withdraw A + after t : withdraw B )
	        2 BTC ~> WIN:Contract
            ), 6 BTC > 'x
        | { A : a # N } 
        | { B : b # M } .

    eq WIN = reveal (a, b) if | ref(a) | == | ref(b) | . withdraw A
           + reveal (a, b) if | ref(a) | != | ref(b) | . withdraw B .

    eq WIN' = WIN
            + (after t' : reveal a . withdraw A)
            + (after t' : reveal b . withdraw B) .

    *** strategies

    *** No one destroy a deposit
    ***eq strategy(S:SemConfiguration, A:Participant authorize-destroy-of x:Name) = false .

    *** A reveals any secret (default any participant reveals any secret)
    ***eq strategy(S:SemConfiguration, A reveal a:Secret) = true .

    *** B does not reveal any secret
    eq strategy(S:SemConfiguration, B reveal a:Secret) = false .

    *** No one reveal a secret
    ***eq strategy(S:SemConfiguration, A:Participant reveal a:Secret) = false .

    *** B authorizes any contract
    ***eq strategy(S:SemConfiguration, B authorize D:GuardedContract in y:Name) = true .

    *** No one authorize any contract
    ***eq strategy(S:SemConfiguration, A:Participant authorize D:Contract in y:Name) = false .
endm

smod LOTTERY-CHECK is 
    protecting BITML-CHECK .
    including Example-LOTTERY .
endsm

*** red in LOTTERY-CHECK : modelCheck(LOTTERY, <> contract-free, 'bitml) .
*** red in LOTTERY-CHECK : modelCheck(LIQUID-LOTTERY, <> contract-free, 'bitml) .