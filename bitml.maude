
fmod BITML-SORTS is   
    protecting NAT .
    protecting STRING .
    protecting EXT-BOOL .   *** for short-circuit operations _and-then_ _or-else_

    sort Participant .      *** A B
    sort Value .            *** v v'
    sort Name .             *** x x' y y'
    sort Secret .           *** s s'
    sort Predicate .        *** p
    sort SplitEntry .       *** v -> C
    sort AnonDeposit .      *** <A,v>
    sort AnonContract .     *** <C,v>
    
    ***
    *** Contract
    ***
    sort Contract .         *** C
    sort GuardedContract .  *** D
    sort Tau .              *** tau
    sort PutReveal .        *** put x^ & reveal a^
    sort Withdraw .         *** withdraw A
    sort Split .            *** split ( v -> C, v' -> C' ... )
    sort AuthC .            *** A: D
    sort After .            *** after t : D
    subsorts Tau PutReveal Withdraw Split AuthC After < GuardedContract < Contract .
    
    ***
    *** Contract Preconditions
    ***
    sort ContractPrecondition .        *** G
    sort VolDeposit .                  *** A: ?v @x
    sort PerDeposit .                  *** A: !v @x
    sort CommSecret .                  *** A: secret a
    subsorts VolDeposit PerDeposit CommSecret < ContractPrecondition .
    
    ***
    *** Configurations
    ***
    sort Configuration .        *** Gamma
    sort AdvContract .          *** {G}C
    sort ActContract .          *** <C,v>x
    sort Deposit .              *** <A,v>x
    sort Auth .                 *** A[chi] 
    sort ConfSec .              *** {A:a#N}
    sort ConfRev .              *** A:a#N
    sort ConfTime .             *** t
    subsorts AdvContract ActContract Deposit Auth ConfSec ConfRev ConfTime < Configuration .

    ***
    *** Authorization
    ***
    sort AuthAction .           *** chi
    sort CommitSec .            *** # |> {G}C
    sort SpendDep .             *** x |> {G}C
    sort TakeBranch .           *** x |> D
    sort Join .                 *** x,y |> <A,v>
    sort Divide .               *** x |> <A,v> <A,v'>
    sort Donate .               *** x |> B
    sort Destroy .              *** x^,i |> y
    subsort CommitSec SpendDep TakeBranch Join Divide Donate Destroy < AuthAction .
endfm

***
*** Views allow reuse maude modules like List{X} and Set{X}
***
view Name from TRIV to BITML-SORTS is
    sort Elt to Name .
endv

view Secret from TRIV to BITML-SORTS is
    sort Elt to Secret .
endv

view Configuration from TRIV to BITML-SORTS is
    sort Elt to Configuration .
endv

view SplitEntry from TRIV to BITML-SORTS is
    sort Elt to SplitEntry .
endv

view Value from TRIV to BITML-SORTS is
    sort Elt to Value .
endv

view Participant from TRIV to BITML-SORTS is
    sort Elt to Participant .
endv

***
*** BitML Syntax
***
fmod BITML-SYNTAX is
    protecting BITML-SORTS .
    protecting LIST{Name} .
    protecting LIST{Secret} .
    protecting LIST{SplitEntry} .
    protecting LIST{Configuration} .
    protecting LIST{Participant} .
    protecting LIST{Nat} .
    protecting LIST{Value} .
    

    op true : -> Predicate [ctor] .
    op v(_) : Nat -> Value [ctor] .                                 *** v(0) v(1) ...
    op x(_) : String -> Name [ctor] .                               *** x("dep1") x("dep2") ... 
    op s(_) : String -> Secret [ctor] .                             *** s("s1") c("s2") ...
    op _~>_ : Value Contract -> SplitEntry [ctor prec 5] .          *** v' -> C
    op <_,_> : Participant Value -> AnonDeposit [ctor prec 5] .     *** <A,v>
    op <_,_> : Contract Value -> AnonContract [ctor prec 5] .       *** <C,v>

    ***
    *** Contract 
    ***
    op 0 : -> Contract [ctor] .                                                                             *** [contr.id]
    op tau : -> Contract [ctor] .                                                                           *** [contr.tau]
    op put_reveal_if_._ : List{Name} List{Secret} Predicate Contract -> PutReveal [ctor prec 25] .          *** [contr.put-reveal]
    op withdraw_ : Participant -> Withdraw [ctor prec 25] .                                                 *** [contr.withdraw]
    op _[_] : Participant GuardedContract -> AuthC [ctor prec 25] .                                         *** [contr.authorization]
    op after_:_ : Nat GuardedContract -> After [ctor prec 25] .                                             *** [contr.after]
    op split(_) : List{SplitEntry} -> Split [ctor prec 25] .                                                *** [contr.split]
    op _+_ : GuardedContract GuardedContract -> Contract [comm assoc ctor id: 0] .                          *** [contr.sum]

    ***
    *** Contract Preconditions
    ***
    op 0 : -> ContractPrecondition [ctor] .                                                         *** [contr-pre.id]
    op _?_@_ : Participant Value Name -> VolDeposit [ctor prec 25] .                                *** [contr-pre.vol-deposit]
    op _!_@_ : Participant Value Name -> PerDeposit [ctor prec 25] .                                *** [contr-pre.perm-deposit]
    op _secret_ : Participant Secret -> CommSecret [ctor prec 25] .                                 *** [contr-pre.commit-secret]
    op _|_ : ContractPrecondition ContractPrecondition -> ContractPrecondition [comm assoc id: 0] . *** [contr-pre.paral]

    ***
    *** Configurations
    ***
    op 0 : -> Configuration [ctor] .                                                    *** [conf.id]
    op {_}_ : ContractPrecondition Contract -> AdvContract [ctor prec 35] .             *** [conf.contract-advertised]
    op __ : AnonContract Name -> ActContract [ctor prec 15] .                           *** [conf.active-contract]
    op __ : AnonDeposit Name -> Deposit [ctor prec 15] .                                *** [conf.deposit]
    op _[_] : Participant AuthAction -> Auth [ctor prec 35] .                           *** [conf.authorization]
    op {_:_#_} : Participant Secret Nat -> ConfSec [ctor prec 35] .                     *** [conf.committed-secret]
    op _:_#_ : Participant Secret Nat -> ConfRev [ctor prec 35] .                       *** [conf.revealed-secret]
    op time_ : Nat -> ConfTime [ctor prec 35] .                                         *** [conf.time]
    op _|_ : Configuration Configuration -> Configuration [comm assoc ctor id: 0] .     *** [conf.parallel]

    ***
    *** Authorization
    ***
    op #|>_ : AdvContract -> CommitSec [ctor] .                  *** [auth.commit-secret]
    op _|>_ : Name AdvContract -> SpendDep [ctor] .              *** [auth.spend-deposit]
    op _|>_ : Name GuardedContract -> TakeBranch [ctor] .        *** [auth.take-branch]
    op __|>_ : Name Name AnonDeposit -> Join [ctor] .            *** [auth.join]
    op _|>__ : Name AnonDeposit AnonDeposit -> Divide [ctor] .   *** [auth.divide]
    op _|>_ : Name Participant -> Donate [ctor] .                *** [auth.donate]
    op __|>_ : List{Name} Nat Name -> Donate [ctor] .            *** [auth.destroy]
endfm


***
*** Define structural equivalences
***
fmod BITML-STREQ is
    protecting BITML-SYNTAX .
    
    var D : List{Name} .
    var S : List{Secret} .
    var C : Contract .
    var p : Predicate .
        
    op put_._ : List{Name} Contract -> PutReveal .
    op put_if_._ : List{Name} Predicate Contract -> PutReveal .
    op reveal_._ : List{Secret} Contract -> PutReveal .
    op reveal_if_._ : List{Secret} Predicate Contract -> PutReveal .
    op put_reveal_._ : List{Name} List{Secret} Contract -> PutReveal .
    
    eq put D . C = put D reveal nil if true . C .
    eq put D if p . C = put D reveal nil if p . C .
    eq reveal S . C = put nil reveal S if true . C .
    eq reveal S if p . C = put nil reveal S if p . C .
    eq put D reveal S . C = put D reveal S if true . C .
    
    *** TODO: add more...
endfm

***
*** Provide fresh names for deposits and contracts
***
*** Usage:
***
***    fresh( exclude:List{Name} ) : List{Name}
***    fresh( exclude:List{Name}, size:Nat ) : List{Name}
***
fmod BITML-FREENAME is

    protecting BITML-SYNTAX .
    protecting BITML-STREQ .
    protecting CONVERSION .
    
    vars d d' : AnonDeposit .
    vars x y z : Name .
    vars A B : Participant .
    vars v v' : Value .
    vars a a' : AuthAction .
    vars S S' P P' : Configuration .
    var s : Secret .
    var sL : List{Secret} .
    var n n' t : Nat .
    var dL : List{Name} .
    var acc : List{Name} .
    var C C' : Contract .
    var sel : List{SplitEntry} .
    var GC : GuardedContract .
    var cp cp' : ContractPrecondition .
    var advC : AdvContract .
    var p : Predicate .
    var str : String .
    var excludeList : List{Name} .
    var tail : List{Configuration} .

    *** check if a Name appears in a Configuration/AuthAction
    op is _ free in _ : Name List{Name} -> Bool [memo] .
    op is _ free in _ : Name ContractPrecondition -> Bool [memo] .
    op is _ free in _ : Name Contract -> Bool [memo] .
    op is _ free in _ : Name Configuration -> Bool [memo] .
    op is _ free in _ : Name AuthAction -> Bool [memo] .
    
    *** base
    eq is x free in dL = occurs(x, dL) .

    ***
    *** Contract 
    ***
    eq is x free in (0).Contract = false .                                                           *** [contr.id]
    eq is x free in tau = false .                                                                    *** [contr.tau]
    eq is x free in put dL reveal sL if p . C = is x free in dL or-else is x free in C .             *** [contr.put-reveal]
    eq is x free in withdraw A = false .                                                             *** [contr.withdraw]
    eq is x free in A[GC] = is x free in GC .                                                        *** [contr.authorization]
    eq is x free in after t : GC = is x free in GC .                                                 *** [contr.after]
    eq is x free in split( nil ) = false .                                                           *** [contr.split]
    eq is x free in split( (v ~> C) sel ) = is x free in C or-else is x free in split(sel) .         *** [contr.split]
    ceq is x free in C + C' = is x free in C or-else is x free in C' if C =/= 0 /\ C' =/= 0 .        *** [contr.sum]


    ***
    *** Contract Preconditions
    ***
    eq is x free in (0).ContractPrecondition = false .                                               *** [contr-pre.id]
    eq is x free in A ? v @ y = x == y .                                                             *** [contr-pre.vol-deposit]
    eq is x free in A ! v @ y = x == y .                                                             *** [contr-pre.perm-deposit]
    eq is x free in A secret s = false .                                                             *** [contr-pre.commit-secret]
    ceq is x free in cp | cp' = is x free in cp or-else is x free in cp' if cp =/= 0 /\ cp' =/= 0 .  *** [contr-pre.paral]


    ***
    *** Configurations
    ***
    eq is x free in (0).Configuration = false .                                                 *** [conf.id]
    eq is x free in {cp}C = is x free in cp or-else is x free in C .                            *** [conf.contract-advertised]
    eq is x free in < C , v > y = x == y or-else is x free in C .                               *** [conf.active-contract]
    eq is x free in < A , v > y = x == y .                                                      *** [conf.deposit]
    eq is x free in A[a] = is x free in a .                                                     *** [conf.authorization]
    eq is x free in { A : s # n } = false .                                                     *** [conf.committed-secret]
    eq is x free in A : s # n = false .                                                         *** [conf.revealed-secret]
    eq is x free in time n = false .                                                            *** [conf.time]
    ceq is x free in S | S' = is x free in S or-else is x free in S' if S =/= 0 /\ S' =/= 0 .   *** [conf.parallel]


    ***
    *** Authorization
    ***
    eq is x free in #|> advC = is x free in advC .                      *** [auth.commit-secret]
    eq is x free in y |> advC = x == y or-else is x free in advC .      *** [auth.spend-deposit]
    eq is x free in y |> GC = x == y or-else is x free in GC .          *** [auth.take-branch]
    eq is x free in (y z |> d) = x == y or x == z .                     *** [auth.join]
    eq is x free in (y |> d d') = x == y .                              *** [auth.divide]
    eq is x free in (y |> B) = x == y .                                 *** [auth.donate]
    eq is x free in (dL n |> y) = is x free in dL .                     *** [auth.destroy]


    *** return a fresh Name given a Configuration

    op fresh(_) : List{Name} -> List{Name} [memo] .
    op fresh(_,_) : List{Name} Nat -> List{Name} [memo] .    
    op fresh(_,_,_,_,_) : List{Name} Nat Nat Configuration List{Name} -> List{Name} [memo] .

    eq fresh(excludeList) = fresh(excludeList,1,0,0,nil) .
    eq fresh(excludeList,n) = fresh(excludeList,n,0,0,nil) .
    *** generic implementation
    eq fresh(excludeList,n,n',S,acc) = 
        if n <= 0
        then acc
        else if  ((not is x("x_" + string(n')) free in S) and 
                 (not is x("x_" + string(n')) free in excludeList))
             then fresh(excludeList,(n - 1),n' + 1,S, acc x("x_" + string(n')))
             else fresh(excludeList,n,(n' + 1),S,acc)
             fi 
        fi .    
    
    *** convert natural to string (use CONVERSION module)
    op string : Nat -> String .
    eq string(n) = string(n,10) .
endfm

fmod BITML-UTILS is

    protecting BITML-STREQ .
    
    var v : Value .
    var x : Name .
    var tail : List{SplitEntry} .
    var tail2 : List{Name} .
    var e : SplitEntry .
    var C : Contract .
    var S S' : List{Configuration} .
    var n n' N : Nat .
    var a : Secret .
    vars x^ y^ : List{Name} .
    vars a^ : List{Secret} .
    vars v^ : List{Value} .
    vars A B : Participant .
    vars A^ B^ : List{Participant} .
    vars N^ : List{Nat} .
    
    ***
    *** Take a list of split entries and names to creare a configuration of parallel contracts
    *** es. 
    ***     || (v ~> C v' ~> C' v'' ~> C'' ) (x x' x'') == <C,v> x | <C',v'> x' | <C'',v''> x''
    ***
    op ||__ : List{SplitEntry} List{Name} -> Configuration .
    eq || (v ~> C nil) (x nil) = < C, v > x .
    ceq || (v ~> C tail) (x tail2) = < C, v > x | ||(tail)(tail2) if size(tail) == size(tail2) .
    
    *** Sum for values
    op _+_ : Value Value -> Value .
    eq v(n) + v(n') = v (n + n') .
    
    ***
    *** Return the total amount value of a list of split entries
    ***
    op value(_) : List{SplitEntry} -> Value .
    eq value(nil) = v(0) .
    eq value(v ~> C tail) = v + value(tail) .

    ***
    ***
    op ||___ : List{Participant} List{Value} List{Name} -> Configuration .
    eq || (nil).List{Participant} (nil).List{Value} (nil).List{Name} = 0 .
    ceq || (A A^) (v v^) (x x^) = < A, v > x | || A^ v^ x^ if size(A^) == size(v^) /\ size(v^) == size(x^) .
    
    ***
    ***
    op ||___ : List{Participant} List{Secret} List{Nat} -> Configuration .
    eq || (nil).List{Participant} (nil).List{Secret} (nil).List{Nat} = 0 .
    ceq || (A A^) (a a^) (N N^) = A : a # N | || A^ a^ N^ if size(A^) == size(a^) /\ size(a^) == size(N^) .

    ***
    ***
    op listOccurs(_,_) : List{Name} List{Name} -> Bool .
    eq listOccurs(nil,y^) = true .
    eq listOccurs((x x^),y^) = occurs(x,y^) and-then listOccurs(x^,y^) . 
endfm

mod BITML-SEM is

    extending BITML-SYNTAX .
    protecting BITML-STREQ .
    protecting BITML-FREENAME .
    protecting BITML-UTILS .
    
    var A B A' B' A'' B'' : Participant .
    var C : Contract .
    vars v v' v'' v''' : Value .
    vars x y z x' y' z' x'' y'' z'' : Name .
    vars x^ y^ : List{Name} .
    vars a^ : List{Secret} .
    vars v^ : List{Value} .
    vars A^ B^ : List{Participant} .
    var N : Nat .
    vars N^ : List{Nat} .
    vars S S' S'' P P' : Configuration .
    vars a a' : Secret .
    vars n n' : Nat .
    vars s s' : Secret .
    vars s^ : List{Secret} .
    vars l l' : Label .
    vars fv fv' : List{Name} .
    var splitEntries : List{SplitEntry} .
    vars p p' : Predicate .
    
    sorts Label .
    sorts LConfiguration .
    
    subsorts Configuration < LConfiguration .
    
    op init : -> Label [ctor] .
    op {_:__} : Participant Name Name -> Label [ctor] .
    op {_:___} : Participant Name Value Value -> Label [ctor] .
    op {_:__} : Participant Name Participant  -> Label [ctor] .
    op join(_,_) : Name Name -> Label [ctor] .
    op divide(_,_,_) : Name Name Name -> Label [ctor] .
    op donate(_,_) : Name Participant -> Label [ctor] .
    op split(_) : Name -> Label [ctor] .
    op put(_,_,_) : List{Name} List{Secret} Name -> Label [ctor] .
    op [_]_ : List{Name} Configuration -> LConfiguration [frozen ctor] .
    op {_}[_]_ : Label List{Name} Configuration -> LConfiguration [frozen ctor] .

    *** Allow progression of labelled configuration
    crl [Rifl] : {l} [fv] S => [fv'] S' if [fv] S => {l'} [fv'] S' .
    
    crl [C-Split] : [fv] (< (split (splitEntries) ), v > y | S) => { split(y) } [fv fv'] ((|| splitEntries fv') | S ) 
                    if fv' := fresh(fv,size(splitEntries)) /\ occurs(y,fv) /\  v == value(splitEntries) .

    *** prova
    crl [C-Put] : [fv] (< (put x x' x'' reveal a if p . C), v > y | (< A, v''' > x) | (< A', v' > x') | (< A'', v'' > x'') | S) => 
                    { put(x x' x'',nil,y) } [fv z] ( < C, (v + (v' + (v'' + v'')))  > z | S )
                    if z := fresh(fv) . ***/\ occurs(y,fv) /\ listOccurs(x^,fv) /\  p == true .

    *** bo, espande i ||
    crl [C-PutReveal] : [fv] (< (put x^ reveal a^ if p . C), v > y | (|| A^ v^ x^) | (|| B^ a^ N^) | S) => 
                    { put(x^,a^,y) } [fv z] ( < C, v + v^  > z | (|| B^ a^ N^) | S )
                    if z := fresh(fv) . ***/\ occurs(y,fv) /\ listOccurs(x^,fv) /\  p == true .

***    rl [DEF-AUTHJOIN] :  < A , v > x | < A , v' > y | S => { A : x y } ( < A , v > x | < A , v' > y | A[ x y |> < A , v + v' > ] | S ) .
***    crl [DEF-JOIN] :  < A , v > x | < A , v' > y | A[ x y |> < A , v + v' > ] | A[ y x |> < A , v + v' > ] | S => join(x,y) < A , v + v' > z | S if z := freshD(S) . 
***    rl [DEF-AUTHDIVIDE] :  < A , v + v' > x | S => { A : x v v' } ( < A , v + v' > x | A[ x |> < A , v > < A , v' > ] | S ) .
***    crl [DEF-DIVIDE] :  < A , v + v' > x | A[ x |> < A , v > < A , v' > ] | S  => divide(x,y,y') < A , v > y | < A , v' > y' | S if y := freshD(S) /\ y' := freshD(y,S) .
***    rl [DEF-DONATE] :  < A , v > x | S => { A : x B } ( < A , v > x | A[ x |> B ] | S ) .
***    crl [DEF-DONATE] :  < A , v > x | A[ x |> B ] | S  => donate(x,B) < B , v > y | S if y := freshD(S) .
endm

mod BITML is
    protecting BITML-SEM .
endm

mod ODDS-EVENS is
    protecting BITML .
    
    ops A B : -> Participant [ctor] .    
    ops a b : -> Secret .
    op t : -> Nat .
    op p : -> Predicate .  *** 0 ≤ |b | ≤ 1
    op p1 : -> Predicate . *** |a|  =  |b|
    op p2 : -> Predicate . *** |a| =/= |b|
    op OddsEvens : -> Contract .
    op OddsEvensAdv : -> AdvContract .
    op a : -> Secret .
    ops x x' x'' y : -> Name .
    
    eq OddsEvens = split(
        v(2) ~> ( reveal b if p . withdraw B + after t : withdraw A )
        v(2) ~> ( reveal a . withdraw A + after t : withdraw B )
        v(2) ~> ( reveal (a b) if p1 . withdraw A
                + reveal (a b) if p2 . withdraw B ) ) .
    
    eq OddsEvensAdv = [x("x_0")] < OddsEvens, v(6) > x("x_0") .
    
    op ESsplit : -> AdvContract .
    eq ESsplit = [x("x_0")] < split( v(1) ~> 0 v(2) ~> 0 ), v(3) > x("x_0") .

    op ESreveal : -> AdvContract .
    eq ESreveal = [x("x_0") x("x_1")] < reveal a . 0, v(3) > x("x_0") | B : a # 6 .

    var txs : List{Name} .
    var vs : List{Value} .
    var As : List{Participant} .
    op ESputReveal(_,_,_) : List{Name} List{Value} List{Participant} -> AdvContract .
    eq ESputReveal(txs,vs,As) = 
        [txs y] 
        < put txs reveal a if true . 0, v(3) > y 
        |   (|| As vs txs)
        |   (|| B a 10) .

endm


