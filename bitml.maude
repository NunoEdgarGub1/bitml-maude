
load bitml-syntax.maude
load bitml-aux.maude
load range.maude

set print attribute on .    *** enable print attribute (see equation with Failure("..."))

fmod BITML-PREDICATE-SAT is
    protecting BITML-SYNTAX .
    protecting BITML-AUX .
    protecting SATISFACTION .
    protecting RANGE .
    subsort Configuration < State .

    op predicate_ : Predicate -> Prop .

    var b b' : Bool .
    var P P' : Predicate .
    var S S' : Configuration .
    var a : Secret .
    var a^ : Set{Secret} .
    var n m x y s t : Nat .
    var N : Nat .
    var A : Participant .
    vars E E' E'' : Expression .
    vars p p' : Predicate .
    vars R R' : Range .

    ***
    *** Extra operations
    ***
    op _||_ : Predicate Predicate -> Predicate [prec 25 comm] .
    op _<=_ : Expression Expression -> Predicate [prec 22] .
    op _>_ : Expression Expression -> Predicate [prec 22] .
    op _>=_ : Expression Expression -> Predicate [prec 22] .
    op _!=_ : Expression Expression -> Predicate [prec 22 comm] .
    op _<=_<=_ : Expression Expression Expression -> Predicate [prec 22] .
    op _<_<_ : Expression Expression Expression -> Predicate [prec 22] .
    op _<=_<_ : Expression Expression Expression -> Predicate [prec 22] .
    op _<_<=_ : Expression Expression Expression -> Predicate [prec 22] .
    eq P || P' = !(! P && ! P') .
    eq E <= E' = E < E' || E == E' .
    eq E > E' = !(E <= E') .
    eq E >= E' = !(E < E') .
    eq E != E' = !(E == E') .
    eq E <= E' <= E'' = E <= E' && E' <= E'' .
    eq E < E' < E'' = E < E' && E' < E'' .
    eq E <= E' < E'' = E <= E' && E' < E'' .
    eq E < E' <= E'' = E < E' && E' <= E'' .

    ***
    *** Simplifications
    ***
    eq ! ! P = P .
    eq ! True = False .
    eq ! False = True .
    eq True || P = True .
    eq False || P = P .
    eq True && P = P .
    eq False && P = False .
    eq const(n) + const(m) = const(n + m) .
    eq const(n) < const(m) = toExp  n < m .
    eq const(n) == const(m) = toExp n == m .
    eq | const(0) | = const(0) .
    eq | const(n) | = const( rat( ceiling( (log(float(n) + 1.0)) / (log(float(2))) / 7.0 ) ) ) .
    eq | ref(a) | < const(0) = False .
    eq | ref(a) | >= const(0) = True .
    ceq E > const(m) && E > const(n) = E > const(m) if m > n .

    eq S |= predicate P = $eval P [ S ] == Success(true) .
    ceq S | S' |= predicate P = S |= predicate P or-else S' |= predicate P if S =/= 0 /\ S' =/= 0 .
    eq S |= predicate P = false [owise] .

    op toExp_ : Bool -> Predicate [prec 65] .
    eq toExp true = True .
    eq toExp false = False .

    op $eval_[_] : Predicate Configuration -> Try .
    eq $eval True [ S ] = Success(true) .
    eq $eval False [ S ] = Success(false) .
    ceq $eval P && P' [ S ] = Success(b and b') if Success(b) := $eval P [ S ] /\ Success(b') := $eval P' [ S ] .
    ceq $eval ! P [ S ] = Success(not b) if Success(b) := $eval P [ S ] .
    ceq $eval E == E' [ S ] = Success(n == m) if Success(n) := $eval E [ S ] /\ Success(m) := $eval E' [ S ] .
    ceq $eval E < E' [ S ] = Success(n < m) if Success(n) := $eval E [ S ] /\ Success(m) := $eval E' [ S ] .
    
    op $eval_[_] : Expression Configuration -> Try .
    eq $eval const(n) [ S ] = Success(n) .
    eq $eval | ref(a) | [ (A : a # N) | S ] = Success(N) .
    ceq $eval | E | [ S ] = Success(m) if Success(n) := $eval E [ S ] /\ const(m) := | const(n) | .
    ceq $eval E + E' [ S ] = Success(n + m) if Success(n) := $eval E [ S ] /\ Success(m) := $eval E' [ S ] .

    eq $eval P [ S ] = Failure("Unable to evaluate the predicate") [owise print "Error evaluating " P " in " S] .
    eq $eval E [ S ] = Failure("Unable to evaluate the expression") [owise print "Error evaluating " E " in " S] .


    sort PredicateSolution .

    op nil : -> PredicateSolution .
    op _in_ : Secret Range -> PredicateSolution [ctor prec 40] .
    op _and_ : PredicateSolution PredicateSolution -> PredicateSolution [comm assoc id: nil].

    op solution of _ : Predicate -> PredicateSolution .
    eq solution of p = $solution of p (secrets in p) .
    op $solution of _ _ : Predicate Set{Secret} -> PredicateSolution .
    eq $solution of p empty = nil .     
    eq $solution of p (a, a^) = (a in (range a p)) and ($solution of p a^) .     

    op range__ : Secret Predicate -> Range .
    eq range a True = all .
    eq range a False = ][  .
    ceq range a (p && p') = (range a p) âˆ© (range a p') if a in (secrets in p) and a in (secrets in p').
    ceq range a (p && p') = (range a p) if a in (secrets in p) .
    ceq range a (p && p') = (range a p') if a in (secrets in p') .
    ceq range a (! p) = ~ (range a p) if a in (secrets in p) .
    ceq range a (| ref(a) | < E) = [0 ; n] if Success(n) := $eval E [0] .
    ceq range a (E < | ref(a) |) = [n + 1 ; Inf] if Success(n) := $eval E [0] .
    ceq range a (| ref(a) | == E) = [n] if Success(n) := $eval E [0] .
    eq range a p = all [owise] .
endfm

mod BITML-SEM is
    extending BITML-SYNTAX .
    protecting BITML-AUX .
    protecting BITML-PREDICATE-SAT .
    
    var A B A' B' A'' B'' Any : Participant .
    var Part : Set{Participant} .
    var C C' : Contract .
    var D D' : GuardedContract .
    vars v v' v'' v''' : Value .
    vars x y z x' y' z' x'' y'' z'' : Name .
    vars x^ y^ : Set{Name} .
    vars a^ : Set{Secret} .
    vars v^ : List{Value} .
    vars A^ B^ : Set{Participant} .
    vars n^ N^ : List{Nat<} .
    vars t^ t'^ : List{Nat<} .
    vars S S' S'' S''' P P' : Configuration .
    vars a a' : Secret .
    vars n n' N t t' : Nat .
    vars s s' : Secret .
    vars s^ : Set{Secret} .
    vars l l' : Label .
    vars icn cn cn' : Set{Name} .
    var splitEntries : List{SplitEntry} .
    vars p p' : Predicate .
    vars putDeps putSecs : Option .
    
    sort SemConfiguration .
    sort LSemConfiguration .
    subsort SemConfiguration < LSemConfiguration .

    sort Context .
    
    op [_|_|_U_|_] : Nat List{Nat<} Set{Name} Set{Name} Set{Participant} -> Context [ctor frozen] .
    ops Adv Someone : -> Participant .

    op __ : Context Configuration -> SemConfiguration [ctor frozen] .

    op {_}_ : Label SemConfiguration -> LSemConfiguration [ctor frozen] .
    
    op toSemConf_ : Configuration -> SemConfiguration [prec 50] .
    eq toSemConf S = [ 0 | ticks(S) | (names in S) U empty | (participants in S) ] S .

    op toConf_ : SemConfiguration -> Configuration [prec 50] .
    eq toConf C:Context S = S .

    *** Labels
    sort Label .
    
    op _authorize-destroy-of_ : Participant Name -> Label [ctor frozen] .
    op _destroy_ : Participant Name -> Label [ctor frozen] .
    op _split_ : Participant Name -> Label [ctor frozen] .
    op _put(_,_,_) : Participant Set{Name} Set{Secret} Name -> Label [ctor frozen] .
    op _reveal_ : Participant Secret  -> Label [ctor frozen] .
    op _lock-reveal_ : Participant Secret  -> Label [ctor frozen] .
    op _ do withdraw _ _ from _ : Participant Participant Value Name -> Label [ctor frozen] .
    op _authorize_in_ : Participant Contract Name -> Label [ctor frozen] .
    op _lock_in_ : Participant Contract Name -> Label [ctor frozen] .

    op delta_ : Nat -> Label [ctor frozen] .

    *** cv(l) : get the name from a label l
    op cv(_) : Label -> Option .
    eq cv(Any do withdraw A v from x) = Some x .
    eq cv(Any split(x)) = Some x .
    eq cv(Any put(x^,a^,y)) = Some y .
    eq cv(l) = None [owise].
    
    op part(_) : Label -> Participant .
    eq part(Any authorize-destroy-of x) = Any .
    eq part(Any destroy x) = Any .
    eq part(Any split(x)) = Any .
    eq part(Any put(x^,a^,y)) = Any .
    eq part(Any reveal a) = Any .
    eq part(Any lock-reveal a) = Any .
    eq part(Any do withdraw A v from x) = Any .
    eq part(Any authorize D in x) = Any .
    eq part(Any lock D in x) = Any .
    
    sort LockContract .
    sort LockSecretReveal .
    subsort LockContract < Contract .
    subsort LockSecretReveal < Configuration .
    
    op Lock : Contract -> LockContract [ctor frozen] .
    op Lock : ConfSec -> LockSecretReveal [ctor frozen] .

    *** strategies
    op strategy : SemConfiguration Label -> Bool [memo] .
    eq strategy(S:SemConfiguration, l) = true [owise] .         *** default: all moves are enabled

    *** Allow progression of labelled configuration (timed)
    
    crl [Rifl] : {l} [t | t^ | icn U cn | Part] S => {l'} [t' | t'^ | icn U cn' | Part] S' 
        if  [t | t^ | icn U cn | Part] S => {l'} [t' | t'^ | icn U cn' | Part] S' .

    rl [Finalize] : {l} [t | t^ | icn U cn | Part] S => [t | t^ | icn U cn | Part] S .

    ***
    *** [...] S => {l} [...] S'    
    ***
    
    *** NOTE: only initial deposits can be destroyed, i.e. those who are in icn
    crl [Dep-AuthDestroy] : [t | t^ | x, icn U cn | Part] < A , v > x | S => { A authorize-destroy-of x } [t | t^ | icn U cn | Part] < A , v > x | A [ x |># ] | S
                    if  strategy([t | t^ | x, icn U cn | Part] < A , v > x | S, A authorize-destroy-of x) /\
                        None := (searchAuthDestroy A x S) .  *** check that A has not already authorized to destroy x

    crl [Dep-Destroy] : [t | t^ | icn U cn | Part] < A , v > x | A [ x |># ] | S => { Someone destroy x } [t | t^ | icn U cn | Part] S 
                    if  strategy([t | t^ | icn U cn | Part] < A , v > x | A [ x |># ] | S, Someone destroy x) .

    crl [C-Split] : [t | t^ | icn U cn | Part] < (split (splitEntries) ) + C, v > y | S => { Someone split(y) } [t | t^ | icn U cn, cn' | Part] ((|| splitEntries cn') | S )
                    if  strategy([t | t^ | icn U cn | Part] < (split (splitEntries) ) + C, v > y | S, Someone split(y)) /\
                        cn' := fresh(cn,size(splitEntries)) .

    crl [C-PutReveal] : [t | t^ | icn U cn | Part] < (put x^ reveal a^ if p . C) + C', v > y | S => { Someone put(x^,a^,y) } [t | t^ | icn U cn, z | Part] ( < C, v > z | S'')
                    if  strategy([t | t^ | icn U cn | Part] < (put x^ reveal a^ if p . C) + C', v > y | S, Someone put(x^,a^,y)) /\
                        z := fresh(cn) /\ 
                        Some (S' S'') := (deposits x^ S) /\ *** fetch all deposits x^ in S (S' are deposits in S, S'' == S \ S')
                        Some S''' := (secrets a^ S'') /\    *** fetch all secrets a^ in S
                        S''' |= predicate p .

    crl [C-AuthRev] : [t | t^ | icn U cn | Part] {A : a # N} | S => { A reveal a } [t | t^ | icn U cn | Part] (A : a # N | S) 
                    if  strategy([t | t^ | icn U cn | Part] {A : a # N} | S, A reveal a) .

    crl [C-LockAuthRev] : [t | t^ | icn U cn | Part] {A : a # N} | S => { A lock-reveal a } [t | t^ | icn U cn | Part] Lock({A : a # N}) | S 
                    if  strategy([t | t^ | icn U cn | Part] {A : a # N} | S, A lock-reveal a) .

    crl [C-Withdraw] : [t | t^ | icn U cn | Part] < withdraw A + C, v > y | S => { Someone do withdraw A v from y } [t | t^ | icn U cn, z | Part] (< A, v > z | S)
                    if  strategy([t | t^ | icn U cn | Part] < withdraw A + C, v > y | S, Someone do withdraw A v from y) /\
                        z := fresh(cn) .

    crl [C-AuthControl] : [t | t^ | icn U cn | Part] < (A, A^) : D + C, v > y | S => { A authorize D in y } [t | t^ | icn U cn | Part] (< (A, A^) : D + C, v > y | A [ y |> (A, A^) : D ] | S)
                    if  strategy([t | t^ | icn U cn | Part] < (A, A^) : D + C, v > y | S, A authorize D in y) /\
                        None := (searchAuth A ((A, A^) : D) y S) .  *** check that branch D is not already authorized by A

    crl [C-LockAuthControl] : [t | t^ | icn U cn | Part] < (A, A^) : D + C, v > y | S => { A lock D in y } [t | t^ | icn U cn | Part] (< Lock((A, A^) : D) + C, v > y | S)
                    if  strategy([t | t^ | icn U cn | Part] < (A, A^) : D + C, v > y | S, A lock D in y) .

    crl [C-Control1] : [t | t^ | icn U cn | Part] < A^ : after t' : D + C, v > y | S => {l'} [t | t^ | icn U cn' | Part] S'
                    if  t >= t' /\                                                      *** timelocks satisfied
                        Some (S'' S''') := (searchAuth A^ (A^ : after t' : D) y S) /\   *** S'' are authorizations, S''' ==  S \ S''
                        [t | t^ | icn U cn | Part] < D, v > y | S''' => {l'} [t | t^ | icn U cn' | Part] S' /\
                        Some y == cv(l') .                                              *** withdraw/split/put-reveal

    crl [C-Control2] : [t | t^ | icn U cn | Part] < after t' : D + C, v > y | S => {l'} [t | t^ | icn U cn' | Part] S'
                    if  t >= t' /\                                                      *** timelocks satisfied
                        [t | t^ | icn U cn | Part] < D, v > y | S => {l'} [t | t^ | icn U cn' | Part] S' /\       *** D progresses
                        Some y == cv(l') .                                              *** withdraw/split/put-reveal

    crl [C-Control3] : [t | t^ | icn U cn | Part] < A^ : D + C, v > y | S => {l'} [t | t^ | icn U cn' | Part] S'
                    if  Some (S'' S''') := (searchAuth A^ (A^ : D) y S) /\              *** S'' are authorizations, S''' == S \ S''
                        [t | t^ | icn U cn | Part] < D, v > y | S''' => {l'} [t | t^ | icn U cn' | Part] S' /\    *** D progresses
                        Some y == cv(l') .                                              *** withdraw/split/put-reveal

    crl [Delay] : [t | t^ | icn U cn | Part] S => {delta (sd(t',t))} [t' | t'^ | icn U cn | Part] S 
                    if t^ =/= nil /\ t' := head(t^) /\ t'^ := tail(t^) .

endm

mod BITML is
    protecting BITML-SEM .
endm

***
*** Strategies
***
smod BITML-STRAT is
    protecting BITML .
    
    strat default @ SemConfiguration .
    strat all\delay @ SemConfiguration .
    strat bitml-1 @ SemConfiguration .
    strat bitml @ SemConfiguration .
    
    *** default Maude strategy
    sd default := all ! .
    sd all\delay := Rifl{bitml-1} or-else (
        Dep-AuthDestroy
      | Dep-Destroy
      | C-Split
      | C-PutReveal
      | C-AuthRev
      | C-LockAuthRev
      | C-Withdraw
      | C-AuthControl
      | C-Control1{all\delay}
      | C-Control2{all\delay}
      | C-Control3{all\delay} ) .

    sd bitml-1 := all\delay or-else Delay .
    sd bitml := bitml-1 ! ; Finalize .

    *** Examples
    *** srew [1] in BITML-STRAT : S(WIN') using bitml ! .
    *** srew in BITML-STRAT :  toSemConf < after 10 : withdraw A, 10 BTC > 'x using bitml ! .
endsm

***
*** Model checking
***

mod BITML-PREDS is
    protecting BITML .    
    protecting SATISFACTION .
    including LTL-SIMPLIFIER .

    subsort LSemConfiguration < State .
    op contract-free : -> Prop .
    op has-deposit : -> Prop .
    op _has-deposit : Participant -> Prop .
    op _has-deposit>=_ : Participant Value -> Prop .

    var A : Participant .
    var C : Contract .
    var v : Value .
    var x : Name .
    var S : Configuration .
    var t : Nat .
    var t^ : List{Nat<} .
    var icn cn cn' : Set{Name} .
    var l : Label .
    var Part : Set{Participant} .
    var n m : Nat .

    eq < C, v > x | S |= contract-free = false .
    eq [t | t^ | icn U cn | Part] S |= contract-free = S |= contract-free .
    eq {l} [t | t^ | icn U cn | Part] S |= contract-free = S |= contract-free .
    eq S:Configuration |= contract-free = true [owise] .
    eq S:SemConfiguration |= contract-free = true [owise] .
    eq S:LSemConfiguration |= contract-free = true [owise] .

    eq < A, n BTC > x | S |= has-deposit = true .
    eq [t | t^ | icn U cn | Part] S |= has-deposit = S |= has-deposit .
    eq {l} [t | t^ | icn U cn | Part] S |= has-deposit = S |= has-deposit .
    eq S:Configuration |= has-deposit = false [owise] .
    eq S:SemConfiguration |= has-deposit = false [owise] .
    eq S:LSemConfiguration |= has-deposit = false [owise] .
    
    eq S:Configuration |= A has-deposit = S:Configuration |= A has-deposit>= 0 BTC .
    eq S:SemConfiguration |= A has-deposit = S:SemConfiguration |= A has-deposit>= 0 BTC .
    eq S:LSemConfiguration |= A has-deposit = S:LSemConfiguration |= A has-deposit>= 0 BTC .

    ceq S |= A has-deposit>= m BTC = n >= m if n BTC := value of A in S .
    eq [t | t^ | icn U cn | Part] S |= A has-deposit>= v = S |= A has-deposit>= v .
    eq {l} [t | t^ | icn U cn | Part] S |= A has-deposit>= v = S |= A has-deposit>= v .
    eq S:Configuration |= A has-deposit>= v = false [owise] .
    eq S:SemConfiguration |= A has-deposit>= v = false [owise] .
    eq S:LSemConfiguration |= A has-deposit>= v = false [owise] .
endm

smod BITML-CHECK is
    protecting BITML-STRAT .
    protecting BITML-PREDS .
    *** Model checking w/o strategies
    ***including MODEL-CHECKER .
    *** Model checking w strategies
    including STRATEGY-MODEL-CHECKER .
endsm


*** *** *** *** *** *** *** *** *** *** *** *** *** *** *** *** *** *** *** *** *** *** *** *** *** *** *** *** *** ***
*** *** *** *** *** *** *** *** *** *** *** *** *** *** *** *** *** *** *** *** *** *** *** *** *** *** *** *** *** ***
*** *** *** *** *** *** *** *** *** *** *** *** *** *** *** *** *** *** *** *** *** *** *** *** *** *** *** *** *** ***
*** *** *** *** *** *** *** *** *** *** *** *** *** *** *** *** *** *** *** *** *** *** *** *** *** *** *** *** *** ***
*** *** *** *** *** *** *** *** *** *** *** *** *** *** *** *** *** *** *** *** *** *** *** *** *** *** *** *** *** ***
*** *** *** *** *** *** *** *** *** *** *** *** *** *** *** *** *** *** *** *** *** *** *** *** *** *** *** *** *** ***


mod BITML-TEST is  
    protecting BITML .
    ops A B A' B' : -> Participant .
    ops x x' x'' : -> Name .
    ops y y' y'' : -> Name .
    ops z z' z'' : -> Name .
    ops v v' v'' : -> Value .
    ops a a' a'' : -> Secret .
    ops b b' b'' : -> Secret .
    ops x^ y^ z^ : -> Set{Name} . 
    ops v^ : -> List{Value} . 
    ops a^ b^ : -> Set{Secret} . 
    ops n n' N N' t t' : -> Nat .
    ops p p' p'' : -> Predicate .
    ops C C' C'' : -> Contract .
    ops D D' D'' : -> GuardedContract .
    ops l l' l'' : -> Label .
    ops S S' : -> Configuration .
endm

***
*** Example 1.0
***
***     rewrite in Example-1.0 : S .
***
mod Example-1.0 is
    protecting BITML .

    op A : -> Participant .
    op v : -> Value .
    op x : -> Name .
    op S : -> SemConfiguration .

    *** deposit
    eq S = toSemConf < A, v > x .

    *** strategy
    ***     A does not authorize to destroy the deposit x
    eq strategy(S:SemConfiguration, A authorize-destroy-of x) = false .
endm

***
*** Example 1.1
***
***     rewrite in Example-1.1 : S .
***
mod Example-1.1 is
    protecting BITML .

    ops A B : -> Participant .
    ops v v' : -> Value .
    ops x x' y y' : -> Name .
    op S : -> SemConfiguration .

    *** 2 deposits
    eq S = toSemConf < A, v > x | < A, v > x' | < B, v' > y | < B, v' > y' .

    *** strategy
    ***     A does not authorize to destroy any deposit, B does
    *** result
    ***     only B's deposits will be destroyed
    eq strategy(S:SemConfiguration, A authorize-destroy-of x:Name) = false .
endm

***
*** Example 1.2
***
***     rewrite in Example-1.2 : S .
***
mod Example-1.2 is
    protecting BITML .

    op A : -> Participant .
    op v : -> Value .
    op x : -> Name .
    op S : -> SemConfiguration .

    *** deposit
    eq S = toSemConf < A, v > x .

    *** strategy
    ***     block everything
    eq strategy(S:SemConfiguration, l:Label) = false [owise] .
endm

***
*** Example 2.0
***
***     rewrite in Example-2.0 : S .
***
mod Example-2.0 is
    protecting BITML .

    op A : -> Participant .
    op v : -> Value .
    op x : -> Name .
    op S : -> SemConfiguration .

    *** deposit
    eq S = [0 | 0 4 | x U empty | A] < A, v > x .

    *** strategy
    ***     A does not authorize to destroy the deposit x
    eq strategy([t:Nat | t^:List{Nat<} | cn:Set{Name} U cn':Set{Name} | Part:Set{Participant}] S:Configuration, A authorize-destroy-of x) = 
        t:Nat >= 5 .
endm

***
*** Examples Example-LIQUIDITY
***
***
mod Examples-LIQUIDITY is
    protecting BITML .

    ops A B C : -> Participant .
    op v : -> Value .
    ops a b : -> Secret .
    ops t t' N M : -> Nat .
    op LOTTERY : -> SemConfiguration .
    op LIQUID-LOTTERY : -> SemConfiguration .
    op S : Contract -> SemConfiguration .
    ops WIN WIN' TC TC' TC'' : -> Contract .

    eq t = 10 .
    eq t' = 15 .
***    eq N = 1 .
***    eq M = 1 .

    *** lottery
    
    eq LOTTERY = S(WIN) .
    eq LIQUID-LOTTERY = S(WIN') .
    
    eq S(WIN:Contract) = 
        toSemConf
	    < split(
	        2 BTC ~> ( reveal b if const(0) <= | ref(b) | <= const(1) . withdraw B + after t : withdraw A )
	        2 BTC ~> ( reveal a . withdraw A + after t : withdraw B )
	        2 BTC ~> WIN:Contract
            ), 6 BTC > 'x
        | { A : a # N } 
        | { B : b # M } .

    eq WIN = reveal (a, b) if | ref(a) | == | ref(b) | . withdraw A
           + reveal (a, b) if | ref(a) | != | ref(b) | . withdraw B .

    eq WIN' = WIN
            + (after t' : reveal a . withdraw A)
            + (after t' : reveal b . withdraw B) .


    eq TC = reveal a . withdraw A + after t : withdraw B .
    
    eq TC' = reveal a . (
            reveal b . split(
	            1 BTC ~> (withdraw A)
	            1 BTC ~> (withdraw B)
	        )
        )
        + after t : withdraw B .

    eq TC'' = reveal a . (
            reveal b . split(
	            1 BTC ~> (withdraw A)
	            1 BTC ~> (withdraw B)
	        )
	        + after t' : withdraw A
        )
        + after t : withdraw B .

    *** strategies

    *** A never locks her secrets
    eq strategy(S:SemConfiguration, A lock-reveal a:Secret) = false .

    *** A never locks her authorizations
    eq strategy(S:SemConfiguration, A lock D:GuardedContract in x:Name) = false .

    *** No one destroys a deposit
    ***eq strategy(S:SemConfiguration, A:Participant authorize-destroy-of x:Name) = false .

    *** A reveals any secret (default any participant reveals any secret)
    ***eq strategy(S:SemConfiguration, A reveal a:Secret) = true .

    *** B does not reveal any secret
    ***eq strategy(S:SemConfiguration, B reveal a:Secret) = false .

    *** No one reveal a secret
    ***eq strategy(S:SemConfiguration, A:Participant reveal a:Secret) = false .

    *** B authorizes any contract
    ***eq strategy(S:SemConfiguration, B authorize D:GuardedContract in y:Name) = true .

    *** No one authorize any contract
    ***eq strategy(S:SemConfiguration, A:Participant authorize D:Contract in y:Name) = false .
endm

smod LIQUIDITY-CHECK is
    protecting BITML-CHECK .
    including Examples-LIQUIDITY .
endsm

*** red in LIQUIDITY-CHECK : modelCheck(LOTTERY, <> contract-free, 'bitml) .
*** red in LIQUIDITY-CHECK : modelCheck(LIQUID-LOTTERY, <> contract-free, 'bitml) .

*** srew toSemConf < B : withdraw A + withdraw B, 10 BTC > 'x using bitml ! .

***(
==========================================
srewrite in LOTTERY-CHECK : toSemConf < after 10 : withdraw A + reveal a . withdraw B, 1 BTC > 'x | {B : a # N} using bitml .

Solution 1
rewrites: 225 in 3ms cpu (1ms real) (67669 rewrites/second)
result SemConfiguration: [10 | nil | 'x, 'x0 | A, B] Lock({B : a # 1}) | < A, 1 BTC > 'x0

Solution 2
rewrites: 234 in 3ms cpu (1ms real) (70375 rewrites/second)
result SemConfiguration: [10 | nil | 'x, 'x0, 'x1 | A, B] < B, 1 BTC > 'x1 | B : a # 1

No more solutions.
rewrites: 234 in 3ms cpu (1ms real) (70375 rewrites/second)

==========================================
reduce in LOTTERY-CHECK : modelCheck(toSemConf < after 10 : withdraw A + reveal a . withdraw B, 1 BTC > 'x | {B : a # N}, <> contract-free, 'bitml) .
rewrites: 120 in 3ms cpu (1ms real) (36003 rewrites/second)
result Bool: true

==========================================
reduce in LIQUIDITY-CHECK : modelCheck(toSemConf < TC'', 2 BTC > 'x | {A : a # 10} | {B : b # 15}, <> A has-deposit, 'bitml) .
rewrites: 362 in 3ms cpu (4ms real) (108610 rewrites/second)
result Bool: true

==========================================
reduce in LIQUIDITY-CHECK : modelCheck(LIQUID-LOTTERY, []<> A has-deposit>= 4 BTC, 'bitml) .
rewrites: 26709 in 206ms cpu (207ms real) (129576 rewrites/second)
result Bool: true
)

