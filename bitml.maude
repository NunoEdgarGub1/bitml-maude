fmod BITML-SORTS is
    protecting NAT .
    protecting INT .
    protecting FLOAT .
    protecting STRING .
    protecting CONVERSION .
    protecting EXT-BOOL .   *** for short-circuit operations _and-then_ _or-else_

    sort Participant .      *** A B
    sort Value .            *** v v'
    sort Name .             *** x x' y y'
    sort Secret .           *** s s'
    sort SplitEntry .       *** v -> C
    sort AnonDeposit .      *** <A,v>
    sort AnonContract .     *** <C,v>

    ***
    *** Predicate
    ***
    sort Predicate .        *** p
    sort True .             *** true
    sort False .            *** false
    sort And .              *** p && p
    sort Or .               *** p || p
    sort Not .              *** ! p
    sort LT .               *** E < E
    sort LET .              *** E <= E
    sort GT .               *** E > E
    sort GET .              *** E >= E
    sort EQ .               *** E == E
    sort NE .               *** E != E
    subsorts True False And Or Not LT LET GT GET EQ NE < Predicate .

    ***
    *** Expression
    ***
    sort Expression .       *** E
    sort Sum .              *** E + E
    sort Minus .            *** E - E
    sort Size .             *** |a|
    sort SecretReference .  *** a
    sort Constant .         *** N
    subsort Sum Minus Size SecretReference Constant < Expression .

    ***
    *** Contract
    ***
    sort Contract .         *** C
    sort GuardedContract .  *** D
    sort PutReveal .        *** put x^ & reveal a^ if p
    sort Withdraw .         *** withdraw A
    sort Split .            *** split ( v -> C, v' -> C' ... )
    sort AuthC .            *** A: D
    sort After .            *** after t : D
    subsorts PutReveal Withdraw Split AuthC After < GuardedContract < Contract .
    
    ***
    *** Contract Preconditions
    ***
    sort ContractPrecondition .        *** G
    sort VolDeposit .                  *** A: ?v @x
    sort PerDeposit .                  *** A: !v @x
    sort CommSecret .                  *** A: secret a
    subsorts VolDeposit PerDeposit CommSecret < ContractPrecondition .
    
    ***
    *** Configurations
    ***
    sort Configuration .        *** Gamma
    sort AdvContract .          *** {G}C
    sort ActContract .          *** <C,v>x
    sort Deposit .              *** <A,v>x
    sort Auth .                 *** A[chi] 
    sort ConfSec .              *** {A:a#N}
    sort ConfRev .              *** A:a#N
    subsorts AdvContract ActContract Deposit Auth ConfSec ConfRev < Configuration .

    ***
    *** Authorization
    ***
    sort AuthAction .           *** chi
    sort CommitSec .            *** # |> {G}C
    sort SpendDep .             *** x |> {G}C
    sort TakeBranch .           *** x |> D
    sort Join .                 *** x,y |> <A,v>
    sort Divide .               *** x |> <A,v> <A,v'>
    sort Donate .               *** x |> B
    sort Destroy .              *** x^,i |> y
    subsort CommitSec SpendDep TakeBranch Join Divide Donate Destroy < AuthAction .
endfm

***
*** Views allow reuse maude modules like List{X} and Set{X}
***
view Name from TRIV to BITML-SORTS is
    sort Elt to Name .
endv

view Secret from TRIV to BITML-SORTS is
    sort Elt to Secret .
endv

view Configuration from TRIV to BITML-SORTS is
    sort Elt to Configuration .
endv

view SplitEntry from TRIV to BITML-SORTS is
    sort Elt to SplitEntry .
endv

view Value from TRIV to BITML-SORTS is
    sort Elt to Value .
endv

view Participant from TRIV to BITML-SORTS is
    sort Elt to Participant .
endv

***
*** BitML Syntax
***
fmod BITML-SYNTAX is
    protecting BITML-SORTS .
    protecting LIST{Name} .
    protecting SET{Name} .
    protecting LIST{Secret} .
    protecting LIST{SplitEntry} .
    protecting LIST{Configuration} .
    protecting LIST{Participant} .
    protecting SET{Participant} .
    protecting SORTABLE-LIST{Nat<} .
    protecting LIST{Value} .

    op v(_) : Nat -> Value [ctor format (d d b! o d)] .                                     *** v(0) v(1) ...
    op x(_) : String -> Name [ctor format (d d g! o d)] .                                   *** x("dep1") x("dep2") ...
    op s(_) : String -> Secret [ctor format (d d r! o d)] .                                 *** s("s1") c("s2") ...
    op _~>_ : Value Contract -> SplitEntry [ctor prec 5 frozen format (ni d ++ --)] .       *** v' -> C
    op <_,_> : Participant Value -> AnonDeposit [ctor prec 5 frozen format (d d d s d d)] . *** <A,v>
    op <_,_> : Contract Value -> AnonContract [ctor prec 5 frozen format (d d d s d d)] .   *** <C,v>

    ***
    *** Predicates/Expressions
    ***
    op true : -> True [ctor] .
    op false : -> False [ctor] .
    op _||_ : Predicate Predicate -> Or [ctor prec 25 frozen comm] .
    op _&&_ : Predicate Predicate -> And [ctor prec 24 frozen comm] .
    op !_ : Predicate -> Not [ctor prec 23 frozen] .
    op _<_ : Expression Expression -> LT [ctor prec 22 frozen] .
    op _<=_ : Expression Expression -> LET [ctor prec 22 frozen] .
    op _>_ : Expression Expression -> GT [ctor prec 22 frozen] .
    op _>=_ : Expression Expression -> GET [ctor prec 22 frozen] .
    op _==_ : Expression Expression -> NE [ctor prec 22 frozen comm] .
    op _!=_ : Expression Expression -> NE [ctor prec 22 frozen comm] .

    op _+_ : Expression Expression -> Sum [ctor prec 21 frozen comm] .
    op _-_ : Expression Expression -> Minus [ctor prec 21 frozen comm] .
    op |_| : Expression -> Size [ctor prec 21 frozen] .
    op ref(_) : Secret -> SecretReference [ctor prec 21 frozen] .
    op const(_) : Int -> Constant [ctor prec 21 frozen] .

    ***
    *** Contract 
    ***
    op 0 : -> Contract [ctor] .                                                                                     *** [contr.id]
    op put_reveal_if_._ : List{Name} List{Secret} Predicate Contract -> PutReveal [ctor prec 25 frozen] .           *** [contr.put-reveal]
    op withdraw_ : Participant -> Withdraw [ctor prec 25 frozen] .                                                  *** [contr.withdraw]
    op _:_ : Set{Participant} GuardedContract -> AuthC [ctor prec 25 frozen] .                                      *** [contr.authorization]
    op after_:_ : Nat GuardedContract -> After [ctor prec 25 frozen] .                                              *** [contr.after]
    op split(_) : List{SplitEntry} -> Split [ctor prec 25 frozen format (d d ++i n--i d)] .                         *** [contr.split]
    op _+_ : GuardedContract GuardedContract -> GuardedContract [comm assoc ctor id: 0 frozen format (d d d d)] .   *** [contr.sum]

    ***
    *** Contract Preconditions
    ***
    op 0 : -> ContractPrecondition [ctor] .                                                                *** [contr-pre.id]
    op _?_@_ : Participant Value Name -> VolDeposit [ctor prec 25 frozen] .                                *** [contr-pre.vol-deposit]
    op _!_@_ : Participant Value Name -> PerDeposit [ctor prec 25 frozen] .                                *** [contr-pre.perm-deposit]
    op _secret_ : Participant Secret -> CommSecret [ctor prec 25 frozen] .                                 *** [contr-pre.commit-secret]
    op _|_ : ContractPrecondition ContractPrecondition -> ContractPrecondition [comm assoc id: 0 frozen] . *** [contr-pre.paral]

    ***
    *** Configurations
    ***
    op 0 : -> Configuration [ctor] .                                                                            *** [conf.id]
    op {_}_ : ContractPrecondition Contract -> AdvContract [ctor prec 35 frozen] .                              *** [conf.contract-advertised]
    op __ : AnonContract Name -> ActContract [ctor prec 15 frozen format (d s d)] .                             *** [conf.active-contract]
    op __ : AnonDeposit Name -> Deposit [ctor prec 15 frozen format (d s d)] .                                  *** [conf.deposit]
    op _[_] : Participant AuthAction -> Auth [ctor prec 35 frozen] .                                            *** [conf.authorization]
    op {_:_#_} : Participant Secret Nat -> ConfSec [ctor prec 35 frozen] .                                      *** [conf.committed-secret]
    op _:_#_ : Participant Secret Nat -> ConfRev [ctor prec 35 frozen] .                                        *** [conf.revealed-secret]
    op _|_ : Configuration Configuration -> Configuration [comm assoc ctor id: 0 frozen format (d ni d d) ] .   *** [conf.parallel]

    ***
    *** Authorization
    ***
    op #|>_ : AdvContract -> CommitSec [ctor frozen] .                  *** [auth.commit-secret]
    op _|>_ : Name AdvContract -> SpendDep [ctor frozen] .              *** [auth.spend-deposit]
    op _|>_ : Name GuardedContract -> TakeBranch [ctor frozen] .        *** [auth.take-branch]
    op __|>_ : Name Name AnonDeposit -> Join [ctor frozen] .            *** [auth.join]
    op _|>__ : Name AnonDeposit AnonDeposit -> Divide [ctor frozen] .   *** [auth.divide]
    op _|>_ : Name Participant -> Donate [ctor frozen] .                *** [auth.donate]
    op _|># : Name -> Destroy [ctor frozen] .                           *** [auth.destroy]
endfm


***
*** Define structural equivalences
***
fmod BITML-STREQ is
    protecting BITML-SYNTAX .
    
    var x^ : List{Name} .
    var a^ : List{Secret} .
    var C : Contract .
    var p p' : Predicate .
    vars A B : Participant .
    vars A^ B^ : Set{Participant} .
    var D : GuardedContract .
    vars t t' : Nat .
    vars n m n' m' : Nat .
    vars E E' E'' : Expression .

    op tau ._ : Contract -> PutReveal [prec 25 frozen] .
    op put_._ : List{Name} Contract -> PutReveal [prec 25 frozen] .
    op put_if_._ : List{Name} Predicate Contract -> PutReveal [prec 25 frozen] .
    op reveal_._ : List{Secret} Contract -> PutReveal [prec 25 frozen] .
    op reveal_if_._ : List{Secret} Predicate Contract -> PutReveal [prec 25 frozen] .
    op put_reveal_._ : List{Name} List{Secret} Contract -> PutReveal [prec 25 frozen] .

    eq tau . C = put nil reveal nil if true . C .
    eq put x^ . C = put x^ reveal nil if true . C .
    eq put x^ if p . C = put x^ reveal nil if p . C .
    eq reveal a^ . C = put nil reveal a^ if true . C .
    eq reveal a^ if p . C = put nil reveal a^ if p . C .
    eq put x^ reveal a^ . C = put x^ reveal a^ if true . C .
    
    eq empty : D = D .
    eq A : A^ : D = (A, A^) : D .
    eq A^ : A : D = (A^, A) : D .

    eq after 0 : D = D .
    eq after t : after t' : D = after max(t,t') : D .

    eq after t : A : D = A : after t : D .
    *** TODO: add more...
endfm

***
*** Unused
***
fmod BITML-FREENAME is

    protecting BITML-STREQ .
    protecting LIST-AND-SET{Name} .
    
    vars d d' : AnonDeposit .
    vars x y z : Name .
    vars A B : Participant .
    vars v v' : Value .
    vars a a' : AuthAction .
    vars S S' P P' : Configuration .
    var s : Secret .
    var sL : List{Secret} .
    var n n' t : Nat .
    var dL : List{Name} .
    var acc : List{Name} .
    var C C' : Contract .
    var sel : List{SplitEntry} .
    var D D' : GuardedContract .
    var cp cp' : ContractPrecondition .
    var advC : AdvContract .
    var p : Predicate .
    var str : String .
    var excludeList : List{Name} .
    var tail : List{Configuration} .

    *** check if a Name appears in a Configuration/AuthAction
    op is _ free in _ : Name List{Name} -> Bool [memo] .
    op is _ free in _ : Name ContractPrecondition -> Bool [memo] .
    op is _ free in _ : Name Contract -> Bool [memo] .
    op is _ free in _ : Name Configuration -> Bool [memo] .
    op is _ free in _ : Name AuthAction -> Bool [memo] .
    
    *** base
    eq is x free in dL = occurs(x, dL) .

    ***
    *** Contract 
    ***
    eq is x free in (0).Contract = false .                                                           *** [contr.id]
    eq is x free in put dL reveal sL if p . C = is x free in dL or-else is x free in C .             *** [contr.put-reveal]
    eq is x free in withdraw A = false .                                                             *** [contr.withdraw]
    eq is x free in A : D = is x free in D .                                                         *** [contr.authorization]
    eq is x free in after t : D = is x free in D .                                                   *** [contr.after]
    eq is x free in split( nil ) = false .                                                           *** [contr.split]
    eq is x free in split( (v ~> C) sel ) = is x free in C or-else is x free in split(sel) .         *** [contr.split]
    ceq is x free in C + C' = is x free in C or-else is x free in C' if C =/= 0 /\ C' =/= 0 .        *** [contr.sum]


    ***
    *** Contract Preconditions
    ***
    eq is x free in (0).ContractPrecondition = false .                                               *** [contr-pre.id]
    eq is x free in A ? v @ y = x == y .                                                             *** [contr-pre.vol-deposit]
    eq is x free in A ! v @ y = x == y .                                                             *** [contr-pre.perm-deposit]
    eq is x free in A secret s = false .                                                             *** [contr-pre.commit-secret]
    ceq is x free in cp | cp' = is x free in cp or-else is x free in cp' if cp =/= 0 /\ cp' =/= 0 .  *** [contr-pre.paral]


    ***
    *** Configurations
    ***
    eq is x free in (0).Configuration = false .                                                 *** [conf.id]
    eq is x free in {cp}C = is x free in cp or-else is x free in C .                            *** [conf.contract-advertised]
    eq is x free in < C , v > y = x == y or-else is x free in C .                               *** [conf.active-contract]
    eq is x free in < A , v > y = x == y .                                                      *** [conf.deposit]
    eq is x free in A[a] = is x free in a .                                                     *** [conf.authorization]
    eq is x free in { A : s # n } = false .                                                     *** [conf.committed-secret]
    eq is x free in A : s # n = false .                                                         *** [conf.revealed-secret]
    ceq is x free in S | S' = is x free in S or-else is x free in S' if S =/= 0 /\ S' =/= 0 .   *** [conf.parallel]

    ***
    *** Authorization
    ***
    eq is x free in #|> advC = is x free in advC .                      *** [auth.commit-secret]
    eq is x free in y |> advC = x == y or-else is x free in advC .      *** [auth.spend-deposit]
    eq is x free in y |> D = x == y or-else is x free in D .            *** [auth.take-branch]
    eq is x free in (y z |> d) = x == y or x == z .                     *** [auth.join]
    eq is x free in (y |> d d') = x == y .                              *** [auth.divide]
    eq is x free in (y |> B) = x == y .                                 *** [auth.donate]
    eq is x free in (y |>#) = x == y .                                  *** [auth.destroy]

    op names in _ : ContractPrecondition -> Set{Name} [memo] .
    op names in _ : Contract -> Set{Name} [memo] .
    op names in _ : Configuration -> Set{Name} [memo] .
    op names in _ : AuthAction -> Set{Name} [memo] .

***    eq names in C = empty [owise] .
***    eq names in cp = empty [owise] .
***    eq names in S = empty [owise] .
***    eq names in a = empty [owise] .

    ***
    *** Contract 
    ***
    eq names in (0).Contract = empty .                                              *** [contr.id]
    eq names in (put dL reveal sL if p . C) = makeSet(dL), (names in C) .           *** [contr.put-reveal]
    eq names in (withdraw A) = empty .                                              *** [contr.withdraw]
    eq names in (A : D) = names in D .                                              *** [contr.authorization]
    eq names in (after t : D) = names in D .                                        *** [contr.after]
    eq names in (split( nil )) = empty .                                            *** [contr.split]
    eq names in (split( (v ~> C) sel )) = (names in C), (names in (split(sel))) .   *** [contr.split]
    ceq names in (C + C') = (names in C), (names in C') if C =/= 0 /\ C' =/= 0 .    *** [contr.sum]


    ***
    *** Contract Preconditions
    ***
    eq names in (0).ContractPrecondition = empty .                                      *** [contr-pre.id]
    eq names in (A ? v @ y) = y .                                                       *** [contr-pre.vol-deposit]
    eq names in (A ! v @ y) = y .                                                       *** [contr-pre.perm-deposit]
    eq names in (A secret s) = empty .                                                  *** [contr-pre.commit-secret]
    ceq names in (cp | cp') = (names in cp), (names in cp') if cp =/= 0 /\ cp' =/= 0 .  *** [contr-pre.paral]


    ***
    *** Configurations
    ***
    eq names in (0).Configuration = empty .                                         *** [conf.id]
    eq names in ({cp}C) = (names in cp), (names in C) .                             *** [conf.contract-advertised]
    eq names in (< C , v > y) = y, (names in C) .                                   *** [conf.active-contract]
    eq names in (< A , v > y) = y .                                                 *** [conf.deposit]
    eq names in (A[a]) = names in a .                                               *** [conf.authorization]
    eq names in ({ A : s # n }) = empty .                                           *** [conf.committed-secret]
    eq names in (A : s # n) = empty .                                               *** [conf.revealed-secret]
    ceq names in (S | S') = (names in S), (names in S') if S =/= 0 /\ S' =/= 0 .    *** [conf.parallel]

    ***
    *** Authorization
    ***
    eq names in (#|> advC) = (names in advC) .      *** [auth.commit-secret]
    eq names in (y |> advC) = y, (names in advC) .  *** [auth.spend-deposit]
    eq names in (y |> D) = y, (names in D) .        *** [auth.take-branch]
    eq names in (y z |> d) = y, z .                 *** [auth.join]
    eq names in (y |> d d') = y .                   *** [auth.divide]
    eq names in (y |> B) = y .                      *** [auth.donate]
    eq names in (x |>#) = x .                       *** [auth.destroy]
endfm

fmod BITML-UTILS is

    protecting BITML-STREQ .
    protecting BITML-FREENAME .
    protecting SORTABLE-LIST-AND-SET{Nat<} .

    var v : Value .
    var x y x' y' x'' y'' : Name .
    var tail : List{SplitEntry} .
    var tail2 : List{Name} .
    var e : SplitEntry .
    var C C' : Contract .
    vars D D' : GuardedContract .
    var S S' S'' S''' : Configuration .
    var n n' N : Nat .
    var a : Secret .
    vars x^ y^ : List{Name} .
    vars X0 : Set{Name} .
    vars a^ : List{Secret} .
    vars v^ : List{Value} .
    vars A B : Participant .
    vars A^ B^ : Set{Participant} .
    vars N^ : List{Nat<} .
    var accConf : Configuration .    
    var n^ : List{Nat<} .
    var p : Predicate .
    var sel : List{SplitEntry} .
 
    ***
    *** return a fresh Name
    ***
    op fresh(_) : List{Name} -> List{Name} [memo] .
    op fresh(_,_) : List{Name} Nat -> List{Name} [memo] .    
    op $fresh(_,_,_,_) : List{Name} Nat Nat List{Name} -> List{Name} [memo] .

    eq fresh(x^) = fresh(x^,1) .
    eq fresh(x^,n) = $fresh(x^,n,0,nil) .
    *** generic implementation
    ceq $fresh(x^,n,n',y^) =
        if n <= 0
        then y^
        else if  occurs(x,x^)        
             then $fresh(x^,n,(n' + 1),y^)
             else $fresh(x^,(n + -1),(n' + 1),(y^ x))
             fi 
        fi 
    if x := x("x_" + str(n')).    
    
    ***
    *** convert natural to string (use CONVERSION module)
    ***
    op str(_) : Nat -> String [memo] .
    eq str(n) = string(n, 10) .
    
    
    ***
    *** Take a list of split entries and names to create a configuration of parallel contracts
    *** es. 
    ***     || (v ~> C v' ~> C' v'' ~> C'' ) (x x' x'') == <C,v> x | <C',v'> x' | <C'',v''> x''
    ***
    op ||__ : List{SplitEntry} List{Name} -> Configuration [memo] .
    eq || (v ~> C nil) (x nil) = < C, v > x .
    ceq || (v ~> C tail) (x tail2) = < C, v > x | ||(tail)(tail2) if size(tail) == size(tail2) .
    
    *** Sum for values
    op _+_ : Value Value -> Value [memo] .
    eq v(n) + v(n') = v (n + n') .
    
    ***
    *** Return the total amount value of a list of split entries
    ***
    op value(_) : List{SplitEntry} -> Value [memo] .
    eq value(nil) = v(0) .
    eq value(v ~> C tail) = v + value(tail) .

    ***
    *** Option
    ***     None
    ***     Some(Any)
    ***
    sort Option None Some .
    subsorts None Some < Option .
    op None : -> None [ctor].
    op Some_ : Universal -> Some [ctor poly(1)].

    ***
    *** Convert Some(Configuration) to Configuration
    ***
    op toConf_ : Some -> Configuration .
    eq toConf Some S = S .

    ***
    *** Given a list of names x^ and S, split the deposits from S.
    *** Return a Some(D R) with D == all deposits in S and R == S \ D,
    *** or None if some deposit is not found.
    ***
    op deposits__ : List{Name} Configuration -> Option [memo] .
    eq deposits x^ S = depositsTR x^ S 0 .
    op depositsTR___ : List{Name} Configuration Configuration -> Option [memo] .
    eq depositsTR nil S accConf = Some (accConf S) .    *** base case
    eq depositsTR (x x^) ((< A , v > x) | S) accConf = depositsTR x^ S (accConf | < A , v > x) .
    eq depositsTR x^ S accConf = None [owise].

    ***
    *** Given a list of secrets a^ and S, fetch all the secrets in S.
    *** Return a Some(S') with S' == all secrets in S,
    *** or None if some secret is not found.
    ***
    op secrets__ : List{Secret} Configuration -> Option [memo] .
    eq secrets a^ S = $secrets a^ S 0 .
    op $secrets___ : List{Secret} Configuration Configuration -> Option [memo] .
    eq $secrets nil S accConf = Some accConf .    *** base case
    eq $secrets (a a^) ((A : a # N) | S) accConf = $secrets a^ S (accConf | A : a # N) .
    eq $secrets a^ S accConf = None [owise].


    ***
    *** Given a set of participants A^ and a guarded contract D,
    *** search for all A [ y |> D ] within a configuration S.
    *** Return a Some(S' R) with S' == all the authorization A [ y |> D ] and R == S \ S'
    *** or None if some authorization is not found.
    ***
    op searchAuth____ : Set{Participant} GuardedContract Name Configuration -> Option [memo] .
    eq searchAuth A^ D y S = $searchAuth A^ D y S 0 .
    op $searchAuth_____ : Set{Participant} GuardedContract Name Configuration Configuration -> Option [memo] .
    eq $searchAuth empty D y S accConf = Some (accConf S) .    *** base case
    eq $searchAuth (A, A^) D y (A [ y |> D ] | S) accConf = $searchAuth A^ D y S (accConf | A [ y |> D ]) .
    eq $searchAuth A^ D y S accConf = None [owise] .

    ***
    *** Given a participant A and a deposit name,
    *** search for destroy authorization A [ x |># ] within a configuration S.
    *** Return a Some(S' R) with S' == the authorization A [ x |># ] and R == S \ S'
    *** or None if the authorization is not found.
    ***
    op searchAuthDestroy___ : Participant Name Configuration -> Option [memo] .
    eq searchAuthDestroy A x (A [ x |># ] | S) = Some ((A [ x |># ]) S) .
    eq searchAuthDestroy A x S = None [owise] .

    ***
    *** Return a ordered set of absolute times
    ***
    op ticks : Configuration -> Set{Nat<} [memo] .
    eq ticks(S) = ticks(S, names in S) .

    op ticks : Configuration Set{Name}-> Set{Nat<} [memo] .
    eq ticks(S, X0) = makeSet(sort ($ticks(S, nil, X0))) .

    *** tail-recursion on Configuration
    op $ticks : Configuration List{Nat<} Set{Name} -> List{Nat<} [memo] .    
    eq $ticks(< C, v > x, n^, X0) = if x in X0 then $ticks(C, n^) else n^ fi .
    ceq $ticks(S | S', n^, X0) = $ticks(S, n^, X0) $ticks(S', n^, X0) if S =/= 0 /\ S' =/= 0 .
    eq $ticks(S, n^, X0) = n^ [owise] .

    *** tail-recursion on Contracts
    op $ticks : Contract List{Nat<} -> List{Nat<} [memo] .
    eq $ticks(put x^ reveal a^ if p . C, n^) = $ticks(C, n^) .
    eq $ticks(withdraw A, n^) = n^ .
    eq $ticks(A^ : D, n^) = $ticks(D, n^) .
    eq $ticks(after n : D, n^) = $ticks(D, n n^) .
    eq $ticks(split(nil),n^) = n^ .
    eq $ticks(split( (v ~> C) sel ), n^) = $ticks(split(sel), n^) $ticks(C, n^) .
    ceq $ticks(C + C', n^) = $ticks(C, n^) $ticks(C', n^) if C =/= 0 /\ C' =/= 0 .
    eq $ticks(C, n^) = n^ [owise] .
endfm

fmod BITML-PREDICATE-SAT is
    protecting BITML-UTILS .
    protecting SATISFACTION .
    subsort Configuration < State .

    op predicate_ : Predicate -> Prop .

    var p p' : Predicate .
    var S S' : Configuration .
    var a : Secret .
    var n m : Int .
    var N : Nat .
    var A : Participant .
    vars E E' E'' : Expression .

    eq S |= predicate p = $eval p [ S ] .
    ceq S | S' |= predicate p = S |= predicate p or-else S' |= predicate p if S =/= 0 /\ S' =/= 0 .
    eq S |= predicate p = false [owise] .

    op $eval_[_] : Predicate Configuration -> Bool .
    eq $eval p && p' [ S ] = $eval p [ S ] and-then $eval p' [ S ] .
    eq $eval p || p' [ S ] = $eval p [ S ] or-else $eval p' [ S ] .
    eq $eval ! p [ S ] = not ( $eval p [ S ] ) .
    eq $eval E != E' [ S ] = $eval E [ S ] =/= $eval E' [ S ] .
    eq $eval E == E' [ S ] = $eval E [ S ] == $eval E' [ S ] .
    eq $eval E < E' [ S ] = $eval E [ S ] < $eval E' [ S ] .
    eq $eval E <= E' [ S ] = $eval E [ S ] <= $eval E' [ S ] .
    eq $eval E > E' [ S ] = $eval E [ S ] > $eval E' [ S ] .
    eq $eval E >= E' [ S ] = $eval E [ S ] >= $eval E' [ S ] .
    eq $eval true [ S ] = true .
    eq $eval false [ S ] = false .
    
    op $eval_[_] : Expression Configuration -> Int .
    eq $eval const(n) [ S ] = n .
    eq $eval | ref(a) | [ (A : a # N) | S ] = N .
    ceq $eval | E | [ S ] = rat( ceiling( (log(float(n))) / (log(float(2))) / 7.0 ) ) if n := $eval E [ S ].
    eq $eval E + E' [ S ] = $eval E [ S ] + $eval E' [ S ] .
    eq $eval E - E' [ S ] = $eval E [ S ] - $eval E' [ S ] .

    ***
    *** Simplifications
    ***
    eq ! (true).True = (false).False .
    eq ! (false).False = (true).True .
    eq (true).True || p = (true).True .
    eq (false).False && p = (false).False .
    eq (false).False || p = p .
    eq (true).True && p = p .
    eq const(n) + const(m) = const(n + m) .
    eq const(n) - const(m) = const(n + (- m)) .
    eq const(n) < const(m) = if n < m then (true).True else (false).False fi .
    eq const(n) <= const(m) = if n <= m then (true).True else (false).False fi .
    eq const(n) > const(m) = if n > m then (true).True else (false).False fi .
    eq const(n) >= const(m) = if n >= m then (true).True else (false).False fi .
    eq const(n) == const(m) = if n == m then (true).True else (false).False fi .
    eq const(n) != const(m) = if n =/= m then (true).True else (false).False fi .
    eq | const(n) | = const( rat( ceiling( (log(float(n))) / (log(float(2))) / 7.0 ) ) ) .

    ***
    *** Extra operations
    ***
    op _<=_<=_ : Expression Expression Expression -> Predicate .
    eq E <= E' <= E'' = E <= E' && E' <= E'' .

    op _<_<_ : Expression Expression Expression -> Predicate .
    eq E < E' < E'' = E < E' && E' < E'' .

    op _<=_<_ : Expression Expression Expression -> Predicate .
    eq E <= E' < E'' = E <= E' && E' < E'' .

    op _<_<=_ : Expression Expression Expression -> Predicate .
    eq E < E' <= E'' = E < E' && E' <= E'' .
endfm

mod BITML-SEM is
    extending BITML-SYNTAX .
    protecting BITML-STREQ .
    protecting BITML-FREENAME .
    protecting BITML-UTILS .
    protecting BITML-PREDICATE-SAT .
    
    var A B A' B' A'' B'' : Participant .
    var C C' : Contract .
    var D D' : GuardedContract .
    vars v v' v'' v''' : Value .
    vars x y z x' y' z' x'' y'' z'' : Name .
    vars x^ y^ : List{Name} .
    vars a^ : List{Secret} .
    vars v^ : List{Value} .
    vars A^ B^ : Set{Participant} .
    vars n^ N^ : List{Nat<} .
    vars t^ t'^ : Set{Nat<} .
    vars S S' S'' S''' P P' : Configuration .
    vars a a' : Secret .
    vars n n' N t t' : Nat .
    vars s s' : Secret .
    vars s^ : List{Secret} .
    vars l l' : Label .
    vars fv fv' : List{Name} .
    var splitEntries : List{SplitEntry} .
    vars p p' : Predicate .
    vars putDeps putSecs : Option .
    
    sorts Label .

    sort SemConfiguration .
    sort LSemConfiguration .
    subsort SemConfiguration < LSemConfiguration .

    sort SemTConfiguration .
    sort LSemTConfiguration .
    subsort SemTConfiguration < LSemTConfiguration .
    
    op [_]_ : Set{Name} Configuration -> SemConfiguration [ctor frozen] .
    op [_|_|_]_ : Nat Set{Nat<} Set{Name} Configuration -> SemTConfiguration [ctor frozen] .

    op {_}_ : Label SemConfiguration -> LSemConfiguration [ctor frozen] .
    op {_}_ : Label SemTConfiguration -> LSemTConfiguration [ctor frozen] .
    
    op toSemTConf_ : Configuration -> SemTConfiguration [prec 50] .
    eq toSemTConf S = [ 0 | ticks(S) | (names in S) ] S .

    *** Labels
    op delta_ : Nat -> Label [ctor frozen] .
    op _withdraw_from_ : Participant Value Name -> Label [ctor frozen] .
    op split_ : Name -> Label [ctor frozen] .
    op destroy_ : Name -> Label [ctor frozen] .
    op put : List{Name} List{Secret} Name -> Label [ctor frozen] .
    op _authorize-destroy-of_ : Participant Name -> Label [ctor frozen] .
    op _reveal_ : Participant Secret  -> Label [ctor frozen] .
    op _authorize_in_ : Participant Contract Name -> Label [ctor frozen] .

    *** cv(l) : get the name from a label l
    op cv(_) : Label -> Option .
    eq cv(A withdraw v from x) = Some x .
    eq cv(split(x)) = Some x .
    eq cv(put(x^,a^,y)) = Some y .
    eq cv(l) = None [owise].

    *** Allow progression of labelled configuration (untimed)
    crl [Rifl] : {l} [fv] S => {l'} [fv'] S' if [fv] S => {l'} [fv'] S' .

    *** Allow progression of labelled configuration (timed)
    crl [Rifl] : {l} [t | t^ | fv] S => {l'} [t' | t'^ | fv'] S' if [t | t^ | fv] S => {l'} [t' | t'^ | fv'] S' .

    ***
    *** [fv] S => {l} [fv'] S'    
    ***
    crl [Dep-AuthDestroy] : [fv] < A , v > x | S => { A authorize-destroy-of x } [fv] < A , v > x | A [ x |># ] | S
                    if  None := (searchAuthDestroy A x S) .  *** check that A has not authorized to destroy x

    rl [Dep-Destroy] : [fv] < A , v > x | A [ x |># ] | S => { destroy x } [fv] S .

    crl [C-Split] : [fv] < (split (splitEntries) ), v > y | S => { split(y) } [fv fv'] ((|| splitEntries fv') | S ) 
                    if fv' := fresh(fv,size(splitEntries)) .

    crl [C-PutReveal] : [fv] (< (put (x^) reveal a^ if p . C), v > y | S) => 
                    { put(x^,a^,y) } [fv z] ( < C, v > z | S'')
                    if  z := fresh(fv) /\ 
                        Some (S' S'') := (deposits x^ S) /\ *** fetch all deposits x^ in S (S' are deposits in S, S'' == S \ S')
                        Some S''' := (secrets a^ S) /\      *** fetch all secrets a^ in S
                        S |= predicate p .

    rl [C-AuthRev] : [fv] {A : a # N} | S => { A reveal a } [fv] (A : a # N | S) .

    crl [C-Withdraw] : [fv] < withdraw A, v > y | S => { A withdraw v from y } [fv z] (< A, v > z | S)
                    if  z := fresh(fv) .

    crl [C-AuthControl] : [fv] < (A, A^) : D, v > y | S => { A authorize D in y } [fv] (< (A, A^) : D, v > y | A [ y |> (A, A^) : D ] | S)
                    if  None := (searchAuth A ((A, A^) : D) y S) .  *** check that branch D is not already authorized by A

    crl [C-Control] : [fv] < A^ : after t : D, v > y | S => {l'} [fv'] S'
                    if  Some (S'' S''') := (searchAuth A^ (A^ : after t : D) y S) /\    *** S'' are authorizations, S''' S \ S''
                        [fv] < D, v > y | S''' => {l'} [fv'] S' /\
                        Some y == cv(l') .

    crl [C-Control] : [fv] < after t : D, v > y | S => {l'} [fv'] S'
                    if  [fv] < D, v > y | S => {l'} [fv'] S' /\
                        Some y == cv(l') .

    crl [C-Control] : [fv] < A^ : D, v > y | S => {l'} [fv'] S'
                    if  Some (S'' S''') := (searchAuth A^ (A^ : D) y S) /\    *** S'' are authorizations, S''' S \ S''
                        [fv] < D, v > y | S''' => {l'} [fv'] S' /\
                        Some y == cv(l') .

    crl [C-Sum] : [fv] < D + C, v > y | S => {l'} [fv'] S'
                    if  C =/= 0 /\
                        [fv] < D, v > y | S => {l'} [fv'] S' .

    ***
    *** [t|t^|fv] S => {l} [t'|t^'|fv'] S'    
    ***
    crl [Action] : [t | t^ | fv] S => {l'} [t | t^ | fv'] S'
                    if  [fv] S => {l'} [fv'] S' /\
                        None == cv(l') .            *** not a withdraw/split/put-reveal

    crl [Delay] : [t | t^ | fv] S => {delta (t' + - t)} [t' | t'^ | fv] S 
                    if t^ =/= nil /\ t' := head(t^) /\ t'^ := tail(t^) .

    crl [Timeout] : [t | t^ | fv] < A^ : after t' : D, v > y | S => {l'} [t | t^ | fv'] S'
                    if  t >= t' /\                                                      *** timelocks satisfied
                        [fv] < A^ : after t' : D, v > y | S => {l'} [fv'] S' /\         *** D progresses
                        Some y == cv(l') .                                              *** withdraw/split/put-reveal

    crl [Timeout] : [t | t^ | fv] < after t' : D, v > y | S => {l'} [t | t^ | fv'] S'
                    if  t >= t' /\                                                      *** timelocks satisfied
                        [fv] < after t' : D, v > y | S => {l'} [fv'] S' /\              *** D progresses
                        Some y == cv(l') .                                              *** withdraw/split/put-reveal

    crl [Timeout] : [t | t^ | fv] < A^ : D, v > y | S => {l'} [t | t^ | fv'] S'
                    if  [fv] < A^ : D, v > y | S => {l'} [fv'] S' /\                    *** D progresses
                        Some y == cv(l') .                                              *** withdraw/split/put-reveal

    crl [Sum] : [t | t^ | fv] < D + C, v > y | S => {l'} [t | t^ | fv'] S'
                    if  [fv] < D, v > y | S => {l'} [fv'] S' /\
                        Some y == cv(l') .          *** withdraw/split/put-reveal

endm

mod BITML-PREDS is
    protecting BITML-FREENAME .
    protecting BITML-SEM .
    protecting SATISFACTION .
    subsort Configuration LSemConfiguration LSemTConfiguration < State .

    var A B A' B' A'' B'' : Participant .
    var C C' : Contract .
    var D D' : GuardedContract .
    vars v v' v'' v''' : Value .
    vars x y z x' y' z' x'' y'' z'' : Name .
    vars x^ y^ : List{Name} .
    vars a^ : List{Secret} .
    vars v^ : List{Value} .
    vars A^ B^ : Set{Participant} .
    vars n^ N^ : List{Nat<} .
    vars t^ t'^ : Set{Nat<} .
    vars S S' S'' S''' P P' : Configuration .
    var LConf : LSemConfiguration .
    var LTConf : LSemTConfiguration .
    vars a a' : Secret .
    vars n n' N t t' : Nat .
    vars s s' : Secret .
    vars s^ : List{Secret} .
    vars l l' : Label .
    vars fv fv' : List{Name} .
    var splitEntries : List{SplitEntry} .
    vars p p' : Predicate .
    vars putDeps putSecs : Option .
    
    *** check that all free names in S are in [fv], and viceversa
    op fvAreTraced : -> Prop .
    eq S |= fvAreTraced = [(names in S)] S |= fvAreTraced .
    eq [fv] S |= fvAreTraced = fv == names in S .
    eq [t | t^ | fv] S |= fvAreTraced = [fv] S |= fvAreTraced .
    eq {l} [fv] S |= fvAreTraced = [fv] S |= fvAreTraced .
    eq {l} [t | t^ | fv] S |= fvAreTraced = [fv] S |= fvAreTraced .
    ceq [fv] S | S' |= fvAreTraced = [fv] S |= fvAreTraced or-else [fv] S' |= fvAreTraced if S =/= 0 /\ S' =/= 0 .
    eq [t | t^ | fv] S | S' |= fvAreTraced = S | S' |= fvAreTraced .
    eq {l} [t | t^ | fv] S | S' |= fvAreTraced = S | S' |= fvAreTraced .
    eq LConf |= fvAreTraced = false [owise] .
    eq LTConf |= fvAreTraced = false [owise] .

    *** check for an empty contract
    op emptySum : -> Prop .
    eq < (0).Contract, v > x |= emptySum = true .
    eq [fv] S |= emptySum = S |= emptySum .
    eq [t | t^ | fv] S |= emptySum = S |= emptySum .
    eq {l} [fv] S |= emptySum = S |= emptySum .
    eq {l} [t | t^ | fv] S |= emptySum = S |= emptySum .
    ceq S | S' |= emptySum = S |= emptySum or-else S' |= emptySum if S =/= 0 /\ S' =/= 0 .
    eq [fv] S | S' |= emptySum = S | S' |= emptySum .
    eq [t | t^ | fv] S | S' |= emptySum = S | S' |= emptySum .
    eq {l} [t | t^ | fv] S | S' |= emptySum = S | S' |= emptySum .
    eq LConf |= emptySum = false [owise] .
    eq LTConf |= emptySum = false [owise] .

    *** check for contracts or deposits with zero-value
    op zeroValue : -> Prop .
    eq < A, v(0) > x |= zeroValue = true .
    eq < C, v(0) > x |= zeroValue = true .
    eq [fv] S |= zeroValue = S |= zeroValue .
    eq [t | t^ | fv] S |= zeroValue = S |= zeroValue .
    eq {l} [fv] S |= zeroValue = S |= zeroValue .
    eq {l} [t | t^ | fv] S |= zeroValue = S |= zeroValue .
    ceq S | S' |= zeroValue = S |= zeroValue or-else S' |= zeroValue if S =/= 0 /\ S' =/= 0 .
    eq [fv] S | S' |= zeroValue = S | S' |= zeroValue .
    eq [t | t^ | fv] S | S' |= zeroValue = S | S' |= zeroValue .
    eq {l} [t | t^ | fv] S | S' |= zeroValue = S | S' |= zeroValue .
    eq LConf |= zeroValue = false [owise] .
    eq LTConf |= zeroValue = false [owise] .

    op put-ok : -> Prop .
    ceq < put x^ reveal a^ if p . C + C', v > x | S |= put-ok = true if (S |= predicate p) /\ deposits x^ S =/= None .
    eq [fv] S |= put-ok = S |= put-ok .
    eq [t | t^ | fv] S |= put-ok = S |= put-ok .
    eq {l} [fv] S |= put-ok = S |= put-ok .
    eq {l} [t | t^ | fv] S |= put-ok = S |= put-ok .
    eq S |= put-ok = false [owise] .
    eq LConf |= put-ok = false [owise] .
    eq LTConf |= put-ok = false [owise] .    
endm

mod BITML-CHECK is
    including BITML-PREDS .
    including MODEL-CHECKER .
    including LTL-SIMPLIFIER .
endm

mod BITML is
    protecting BITML-SEM .
endm

