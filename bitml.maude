
fmod BITML-SORTS is   
    protecting NAT .
    protecting STRING .
    protecting EXT-BOOL .   *** for short-circuit operations _and-then_ _or-else_

    sort Participant .      *** A B
    sort Value .            *** v v'
    sort Name .             *** x x' y y'
    sort Secret .           *** s s'
    sort Predicate .        *** p
    sort SplitEntry .       *** v -> C
    sort AnonDeposit .      *** <A,v>
    sort AnonContract .     *** <C,v>
    
    ***
    *** Contract
    ***
    sort Contract .         *** C
    sort GuardedContract .  *** D
    sort Tau .              *** tau
    sort PutReveal .        *** put x^ & reveal a^
    sort Withdraw .         *** withdraw A
    sort Split .            *** split ( v -> C, v' -> C' ... )
    sort AuthC .            *** A: D
    sort After .            *** after t : D
    subsorts Tau PutReveal Withdraw Split AuthC After < GuardedContract < Contract .
    
    ***
    *** Contract Preconditions
    ***
    sort ContractPrecondition .        *** G
    sort VolDeposit .                  *** A: ?v @x
    sort PerDeposit .                  *** A: !v @x
    sort CommSecret .                  *** A: secret a
    subsorts VolDeposit PerDeposit CommSecret < ContractPrecondition .
    
    ***
    *** Configurations
    ***
    sort Configuration .        *** Gamma
    sort AdvContract .          *** {G}C
    sort ActContract .          *** <C,v>x
    sort Deposit .              *** <A,v>x
    sort Auth .                 *** A[chi] 
    sort ConfSec .              *** {A:a#N}
    sort ConfRev .              *** A:a#N
    subsorts AdvContract ActContract Deposit Auth ConfSec ConfRev < Configuration .

    ***
    *** Authorization
    ***
    sort AuthAction .           *** chi
    sort CommitSec .            *** # |> {G}C
    sort SpendDep .             *** x |> {G}C
    sort TakeBranch .           *** x |> D
    sort Join .                 *** x,y |> <A,v>
    sort Divide .               *** x |> <A,v> <A,v'>
    sort Donate .               *** x |> B
    sort Destroy .              *** x^,i |> y
    subsort CommitSec SpendDep TakeBranch Join Divide Donate Destroy < AuthAction .
endfm

***
*** Views allow reuse maude modules like List{X} and Set{X}
***
view Name from TRIV to BITML-SORTS is
    sort Elt to Name .
endv

view Secret from TRIV to BITML-SORTS is
    sort Elt to Secret .
endv

view Configuration from TRIV to BITML-SORTS is
    sort Elt to Configuration .
endv

view SplitEntry from TRIV to BITML-SORTS is
    sort Elt to SplitEntry .
endv

view Value from TRIV to BITML-SORTS is
    sort Elt to Value .
endv

view Participant from TRIV to BITML-SORTS is
    sort Elt to Participant .
endv

***
*** BitML Syntax
***
fmod BITML-SYNTAX is
    protecting BITML-SORTS .
    protecting LIST{Name} .
    protecting LIST{Secret} .
    protecting LIST{SplitEntry} .
    protecting LIST{Configuration} .
    protecting LIST{Participant} .
    protecting SET{Participant} .
    protecting LIST{Nat} .
    protecting LIST{Value} .
    

    op true : -> Predicate [ctor] .
    op v(_) : Nat -> Value [ctor] .                                        *** v(0) v(1) ...
    op x(_) : String -> Name [ctor] .                                      *** x("dep1") x("dep2") ...
    op s(_) : String -> Secret [ctor] .                                    *** s("s1") c("s2") ...
    op _~>_ : Value Contract -> SplitEntry [ctor prec 5 frozen] .          *** v' -> C
    op <_,_> : Participant Value -> AnonDeposit [ctor prec 5 frozen] .     *** <A,v>
    op <_,_> : Contract Value -> AnonContract [ctor prec 5 frozen] .       *** <C,v>

    ***
    *** Contract 
    ***
    op 0 : -> Contract [ctor] .                                                                             *** [contr.id]
    op tau . _ : Contract -> Tau [ctor] .                                                                   *** [contr.tau]
    op put_reveal_if_._ : List{Name} List{Secret} Predicate Contract -> PutReveal [ctor prec 25 frozen] .   *** [contr.put-reveal]
    op withdraw_ : Participant -> Withdraw [ctor prec 25 frozen] .                                          *** [contr.withdraw]
    op _:_ : Set{Participant} GuardedContract -> AuthC [ctor prec 25 frozen] .                                   *** [contr.authorization]
    op after_:_ : Nat GuardedContract -> After [ctor prec 25 frozen] .                                      *** [contr.after]
    op split(_) : List{SplitEntry} -> Split [ctor prec 25 frozen] .                                         *** [contr.split]
    op _+_ : GuardedContract GuardedContract -> GuardedContract [comm assoc ctor id: 0 frozen] .            *** [contr.sum]

    ***
    *** Contract Preconditions
    ***
    op 0 : -> ContractPrecondition [ctor] .                                                                *** [contr-pre.id]
    op _?_@_ : Participant Value Name -> VolDeposit [ctor prec 25 frozen] .                                *** [contr-pre.vol-deposit]
    op _!_@_ : Participant Value Name -> PerDeposit [ctor prec 25 frozen] .                                *** [contr-pre.perm-deposit]
    op _secret_ : Participant Secret -> CommSecret [ctor prec 25 frozen] .                                 *** [contr-pre.commit-secret]
    op _|_ : ContractPrecondition ContractPrecondition -> ContractPrecondition [comm assoc id: 0 frozen] . *** [contr-pre.paral]

    ***
    *** Configurations
    ***
    op 0 : -> Configuration [ctor] .                                                           *** [conf.id]
    op {_}_ : ContractPrecondition Contract -> AdvContract [ctor prec 35 frozen] .             *** [conf.contract-advertised]
    op __ : AnonContract Name -> ActContract [ctor prec 15 frozen] .                           *** [conf.active-contract]
    op __ : AnonDeposit Name -> Deposit [ctor prec 15 frozen] .                                *** [conf.deposit]
    op _[_] : Participant AuthAction -> Auth [ctor prec 35 frozen] .                           *** [conf.authorization]
    op {_:_#_} : Participant Secret Nat -> ConfSec [ctor prec 35 frozen] .                     *** [conf.committed-secret]
    op _:_#_ : Participant Secret Nat -> ConfRev [ctor prec 35 frozen] .                       *** [conf.revealed-secret]
    op _|_ : Configuration Configuration -> Configuration [comm assoc ctor id: 0 frozen] .     *** [conf.parallel]

    ***
    *** Authorization
    ***
    op #|>_ : AdvContract -> CommitSec [ctor frozen] .                  *** [auth.commit-secret]
    op _|>_ : Name AdvContract -> SpendDep [ctor frozen] .              *** [auth.spend-deposit]
    op _|>_ : Name GuardedContract -> TakeBranch [ctor frozen] .        *** [auth.take-branch]
    op __|>_ : Name Name AnonDeposit -> Join [ctor frozen] .            *** [auth.join]
    op _|>__ : Name AnonDeposit AnonDeposit -> Divide [ctor frozen] .   *** [auth.divide]
    op _|>_ : Name Participant -> Donate [ctor frozen] .                *** [auth.donate]
    op __|>_ : List{Name} Nat Name -> Donate [ctor frozen] .            *** [auth.destroy]
endfm


***
*** Define structural equivalences
***
fmod BITML-STREQ is
    protecting BITML-SYNTAX .
    
    var x^ : List{Name} .
    var a^ : List{Secret} .
    var C : Contract .
    var p : Predicate .
    vars A B : Participant .
    vars A^ B^ : Set{Participant} .
    var D : GuardedContract .
    vars t t' : Nat .

    op put_._ : List{Name} Contract -> PutReveal .
    op put_if_._ : List{Name} Predicate Contract -> PutReveal .
    op reveal_._ : List{Secret} Contract -> PutReveal .
    op reveal_if_._ : List{Secret} Predicate Contract -> PutReveal .
    op put_reveal_._ : List{Name} List{Secret} Contract -> PutReveal .
    
    eq put x^ . C = put x^ reveal nil if true . C .
    eq put x^ if p . C = put x^ reveal nil if p . C .
    eq reveal a^ . C = put nil reveal a^ if true . C .
    eq reveal a^ if p . C = put nil reveal a^ if p . C .
    eq put x^ reveal a^ . C = put x^ reveal a^ if true . C .
    
    eq empty : D = D .
    eq A : A^ : D = (A, A^) : D .
    eq A^ : A : D = (A^, A) : D .

    eq after 0 : D = D .
    eq after t : after t' : D = after max(t,t') : D .

    *** TODO: add more...
endfm

***
*** Unused
***
fmod BITML-FREENAME is

    protecting BITML-STREQ .
    
    vars d d' : AnonDeposit .
    vars x y z : Name .
    vars A B : Participant .
    vars v v' : Value .
    vars a a' : AuthAction .
    vars S S' P P' : Configuration .
    var s : Secret .
    var sL : List{Secret} .
    var n n' t : Nat .
    var dL : List{Name} .
    var acc : List{Name} .
    var C C' : Contract .
    var sel : List{SplitEntry} .
    var D D' : GuardedContract .
    var cp cp' : ContractPrecondition .
    var advC : AdvContract .
    var p : Predicate .
    var str : String .
    var excludeList : List{Name} .
    var tail : List{Configuration} .

    *** check if a Name appears in a Configuration/AuthAction
    op is _ free in _ : Name List{Name} -> Bool [memo] .
    op is _ free in _ : Name ContractPrecondition -> Bool [memo] .
    op is _ free in _ : Name Contract -> Bool [memo] .
    op is _ free in _ : Name Configuration -> Bool [memo] .
    op is _ free in _ : Name AuthAction -> Bool [memo] .
    
    *** base
    eq is x free in dL = occurs(x, dL) .

    ***
    *** Contract 
    ***
    eq is x free in (0).Contract = false .                                                           *** [contr.id]
    eq is x free in tau . C = false .                                                                *** [contr.tau]
    eq is x free in put dL reveal sL if p . C = is x free in dL or-else is x free in C .             *** [contr.put-reveal]
    eq is x free in withdraw A = false .                                                             *** [contr.withdraw]
    eq is x free in A : D = is x free in D .                                                         *** [contr.authorization]
    eq is x free in after t : D = is x free in D .                                                   *** [contr.after]
    eq is x free in split( nil ) = false .                                                           *** [contr.split]
    eq is x free in split( (v ~> C) sel ) = is x free in C or-else is x free in split(sel) .         *** [contr.split]
    ceq is x free in C + C' = is x free in C or-else is x free in C' if C =/= 0 /\ C' =/= 0 .        *** [contr.sum]


    ***
    *** Contract Preconditions
    ***
    eq is x free in (0).ContractPrecondition = false .                                               *** [contr-pre.id]
    eq is x free in A ? v @ y = x == y .                                                             *** [contr-pre.vol-deposit]
    eq is x free in A ! v @ y = x == y .                                                             *** [contr-pre.perm-deposit]
    eq is x free in A secret s = false .                                                             *** [contr-pre.commit-secret]
    ceq is x free in cp | cp' = is x free in cp or-else is x free in cp' if cp =/= 0 /\ cp' =/= 0 .  *** [contr-pre.paral]


    ***
    *** Configurations
    ***
    eq is x free in (0).Configuration = false .                                                 *** [conf.id]
    eq is x free in {cp}C = is x free in cp or-else is x free in C .                            *** [conf.contract-advertised]
    eq is x free in < C , v > y = x == y or-else is x free in C .                               *** [conf.active-contract]
    eq is x free in < A , v > y = x == y .                                                      *** [conf.deposit]
    eq is x free in A[a] = is x free in a .                                                     *** [conf.authorization]
    eq is x free in { A : s # n } = false .                                                     *** [conf.committed-secret]
    eq is x free in A : s # n = false .                                                         *** [conf.revealed-secret]
    ceq is x free in S | S' = is x free in S or-else is x free in S' if S =/= 0 /\ S' =/= 0 .   *** [conf.parallel]


    ***
    *** Authorization
    ***
    eq is x free in #|> advC = is x free in advC .                      *** [auth.commit-secret]
    eq is x free in y |> advC = x == y or-else is x free in advC .      *** [auth.spend-deposit]
    eq is x free in y |> D = x == y or-else is x free in D .            *** [auth.take-branch]
    eq is x free in (y z |> d) = x == y or x == z .                     *** [auth.join]
    eq is x free in (y |> d d') = x == y .                              *** [auth.divide]
    eq is x free in (y |> B) = x == y .                                 *** [auth.donate]
    eq is x free in (dL n |> y) = is x free in dL .                     *** [auth.destroy]

endfm

fmod BITML-UTILS is

    protecting BITML-STREQ .
    protecting CONVERSION .
    
    var v : Value .
    var x y x' y' x'' y'' : Name .
    var tail : List{SplitEntry} .
    var tail2 : List{Name} .
    var e : SplitEntry .
    var C : Contract .
    vars D D' : GuardedContract .
    var S S' S'' S''' : Configuration .
    var n n' N : Nat .
    var a : Secret .
    vars x^ y^ : List{Name} .
    vars a^ : List{Secret} .
    vars v^ : List{Value} .
    vars A B : Participant .
    vars A^ B^ : Set{Participant} .
    vars N^ : List{Nat} .
    var accConf : Configuration .    
    
    ***
    *** return a fresh Name
    ***
    op fresh(_) : List{Name} -> List{Name} [memo] .
    op fresh(_,_) : List{Name} Nat -> List{Name} [memo] .    
    op fresh(_,_,_,_) : List{Name} Nat Nat List{Name} -> List{Name} [memo] .

    eq fresh(x^) = fresh(x^,1) .
    eq fresh(x^,n) = fresh(x^,n,0,nil) .
    *** generic implementation
    ceq fresh(x^,n,n',y^) =
        if n <= 0
        then y^
        else if  occurs(x,x^)        
             then fresh(x^,n,(n' + 1),y^)
             else fresh(x^,(n + -1),(n' + 1),(y^ x))
             fi 
        fi 
    if x := x("x_" + string(n')).    
    
    ***
    *** convert natural to string (use CONVERSION module)
    ***
    op string(_) : Nat -> String .
    eq string(n) = string(n,10) .
    
    
    ***
    *** Take a list of split entries and names to creare a configuration of parallel contracts
    *** es. 
    ***     || (v ~> C v' ~> C' v'' ~> C'' ) (x x' x'') == <C,v> x | <C',v'> x' | <C'',v''> x''
    ***
    op ||__ : List{SplitEntry} List{Name} -> Configuration .
    eq || (v ~> C nil) (x nil) = < C, v > x .
    ceq || (v ~> C tail) (x tail2) = < C, v > x | ||(tail)(tail2) if size(tail) == size(tail2) .
    
    *** Sum for values
    op _+_ : Value Value -> Value .
    eq v(n) + v(n') = v (n + n') .
    
    ***
    *** Return the total amount value of a list of split entries
    ***
    op value(_) : List{SplitEntry} -> Value .
    eq value(nil) = v(0) .
    eq value(v ~> C tail) = v + value(tail) .

    ***
    ***
    op ||___ : List{Participant} List{Value} List{Name} -> Configuration .
    eq || (nil).List{Participant} (nil).List{Value} (nil).List{Name} = 0 .
    ceq || (A A^) (v v^) (x x^) = < A, v > x | || A^ v^ x^ if size(A^) == size(v^) /\ size(v^) == size(x^) .
    
    ***
    ***
    op ||___ : List{Participant} List{Secret} List{Nat} -> Configuration .
    eq || (nil).List{Participant} (nil).List{Secret} (nil).List{Nat} = 0 .
    ceq || (A A^) (a a^) (N N^) = A : a # N | || A^ a^ N^ if size(A^) == size(a^) /\ size(a^) == size(N^) .

    ***
    ***
    op listOccurs(_,_) : List{Name} List{Name} -> Bool .
    eq listOccurs(nil,y^) = true .
    eq listOccurs((x x^),y^) = occurs(x,y^) and-then listOccurs(x^,y^) . 
    
    ***
    *** Option
    ***     None
    ***     Some(Any)
    ***
    sort Option None Some .
    subsorts None Some < Option .
    op None : -> None [ctor].
    op Some_ : Universal -> Some [ctor poly(1)].

    ***
    *** Convert Some(Configuration) to Configuration
    ***
    op toConf_ : Some -> Configuration .
    eq toConf Some S = S .    
    
    ***
    *** Given a list of names x^ and S, split the deposits from S.
    *** Return a Some(D R) with D == all deposits in S and R == S \ D,
    *** or None if some deposit is not found.
    ***
    op deposits__ : List{Name} Configuration -> Option .
    eq deposits x^ S = depositsTR x^ S 0 .
    op depositsTR___ : List{Name} Configuration Configuration -> Option .
    eq depositsTR nil S accConf = Some (accConf S) .    *** base case
    eq depositsTR (x x^) ((< A , v > x) | S) accConf = depositsTR x^ S (accConf | < A , v > x) .
    eq depositsTR x^ S accConf = None [owise].

    ***
    *** Given a list of secrets a^ and S, fetch all the secrets in S.
    *** Return a Some(S') with S' == all secrets in S,
    *** or None if some secret is not found.
    ***
    op secrets__ : List{Secret} Configuration -> Option .
    eq secrets a^ S = secretsTR a^ S 0 .
    op secretsTR___ : List{Secret} Configuration Configuration -> Option .
    eq secretsTR nil S accConf = Some accConf .    *** base case
    eq secretsTR (a a^) ((A : a # N) | S) accConf = secretsTR a^ S (accConf | A : a # N) .
    eq secretsTR a^ S accConf = None [owise].


    ***
    *** Given a set of participants A^ and a guarded contract D,
    *** search for all A [ y |> D ] within a configuration S.
    *** Return a Some(S' R) with S' == all the authorization A [ y |> D ]
    *** or None if some authorization is not found.
    ***
    op searchAuth____ : Set{Participant} GuardedContract Name Configuration -> Option .
    eq searchAuth A^ D y S = searchAuthTR A^ D y S 0 .
    op searchAuthTR_____ : Set{Participant} GuardedContract Name Configuration Configuration -> Option .
    eq searchAuthTR empty D y S accConf = Some (accConf S) .    *** base case
    eq searchAuthTR (A, A^) D y (A [ y |> D ] | S) accConf = searchAuthTR A^ D y S (accConf | A [ y |> D ]) .
    eq searchAuthTR A^ D y S accConf = None [owise] .
endfm

mod BITML-SEM is

    extending BITML-SYNTAX .
    protecting BITML-STREQ .
    protecting BITML-FREENAME .
    protecting BITML-UTILS .
    
    var A B A' B' A'' B'' : Participant .
    var C C' : Contract .
    var D D' : GuardedContract .
    vars v v' v'' v''' : Value .
    vars x y z x' y' z' x'' y'' z'' : Name .
    vars x^ y^ : List{Name} .
    vars a^ : List{Secret} .
    vars v^ : List{Value} .
    vars A^ B^ : Set{Participant} .
    vars n^ N^ : List{Nat} .
    vars S S' S'' S''' P P' : Configuration .
    vars a a' : Secret .
    vars n n' N t t' : Nat .
    vars s s' : Secret .
    vars s^ : List{Secret} .
    vars l l' : Label .
    vars fv fv' : List{Name} .
    var splitEntries : List{SplitEntry} .
    vars p p' : Predicate .
    vars putDeps putSecs : Option .
    
    sorts Label .
    sorts FConfiguration .  *** configurations with free variables
    sorts TConfiguration .  *** timed configurations with free variables
    sorts LConfiguration .  *** labelled timed configurations with free variables
    
    subsorts Configuration < FConfiguration < TConfiguration < LConfiguration .
    
    *** Labels
    op init : -> Label [ctor] .
    op _:__ : Participant Name Name -> Label [ctor frozen] .
    op _:___ : Participant Name Value Value -> Label [ctor frozen] .
    op _:__ : Participant Name Participant  -> Label [ctor frozen] .
    op _:_ : Participant Secret  -> Label [ctor frozen] .
    op _:_,_ : Participant Name Contract  -> Label [ctor frozen] .
    op delta_ : Nat -> Label [ctor frozen] .
    op withdraw(_,_,_) : Participant Value Name -> Label [ctor frozen] .
    op split(_) : Name -> Label [ctor frozen] .
    op put(_,_,_) : List{Name} List{Secret} Name -> Label [ctor frozen] .

    op [_]_ : List{Name} Configuration -> FConfiguration [ctor frozen] .
    op <_>_ : Nat FConfiguration -> TConfiguration [ctor frozen] .
    op {_}_ : Label TConfiguration -> LConfiguration [ctor frozen] .

    *** cv(l) : get the name from a label l
    op cv(_) : Label -> Option .
    eq cv(withdraw(A,v,x)) = Some x .
    eq cv(split(x)) = Some x .
    eq cv(put(x^,a^,y)) = Some y .
    eq cv(l) = None [owise].

    *** Allow progression of labelled configuration
    crl [Rifl] : {l} [fv] S => [fv'] S' if [fv] S => {l'} [fv'] S' .

    *** Allow progression of timed labelled configuration
    crl [RiflT] : {l} < t > [fv] S => < t' > [fv'] S' if < t > [fv] S => {l'} < t' > [fv'] S' .
    
    ***
    *** [fv] S => {l} [fv'] S'    
    ***
    crl [C-Split] : [fv] < (split (splitEntries) ), v > y | S => { split(y) } [fv fv'] ((|| splitEntries fv') | S ) 
                    if fv' := fresh(fv,size(splitEntries)) .

    crl [C-PutReveal] : [fv] (< (put (x^) reveal a^ if p . C), v > y | S) => 
                    { put(x^,a^,y) } [fv z] ( < C, v > z | S'')
                    if  z := fresh(fv) /\ 
                        Some (S' S'') := (deposits x^ S) /\ *** S' are deposits in S, S'' == S \ S'
                        Some S''' := (secrets a^ S) /\
                        p == true .

    rl [C-AuthRev] : [fv] {A : a # N} | S => { A : a } [fv] (A : a # N | S) .
    
    crl [C-Withdraw] : [fv] < withdraw A, v > y | S => { withdraw(A,v,y) } [fv z] (< A, v > z | S)
                    if  z := fresh(fv) .
    
    crl [C-AuthControl] : [fv] < (A, A^) : D + C, v > y | S => { A : y, D } [fv] (< (A, A^) : D + C, v > y | A [ y |> (A, A^) : D ] | S)
                    if  None := (searchAuth A ((A, A^) : D) y S) .
    
    crl [C-Control] : [fv] < A^ : after t : D + C, v > y | S => {l'} [fv'] S'
                    if  Some (S'' S''') := (searchAuth A^ (A^ : after t : D) y S) /\    *** S'' are authorizations, S''' S \ S''
                        [fv] < D, v > y | S''' => {l'} [fv'] S' /\
                        Some y == cv(l') .
    
    ***
    *** <t> [fv] S => {l} <t'> [fv'] S'    
    ***
    crl [Action] : < t > [fv] S => {l'} < t > [fv'] S'
                    if  [fv] S => {l'} [fv'] S' /\
                        None == cv(l') .            *** not a withdraw/split/put-reveal
      
    crl [Delay] : < t > [fv] S => {delta n} < t + n > [fv] S 
                    if n := 1 /\ t < 100 .  *** get the best delay from S

    crl [Timeout] : < t > [fv] < A^ : after t : D + C, v > y | S => {l'} < t > [fv'] S'
                    if  [fv] < A^ : after t : D, v > y | S => {l'} [fv'] S' /\
                        Some y == cv(l') .          *** withdraw/split/put-reveal

  
***    op join(_,_) : Name Name -> Label [ctor frozen] .
***    op divide(_,_,_) : Name Name Name -> Label [ctor frozen] .
***    op donate(_,_) : Name Participant -> Label [ctor frozen] .
***    rl [DEF-AUTHJOIN] :  < A , v > x | < A , v' > y | S => { A : x y } ( < A , v > x | < A , v' > y | A[ x y |> < A , v + v' > ] | S ) .
***    crl [DEF-JOIN] :  < A , v > x | < A , v' > y | A[ x y |> < A , v + v' > ] | A[ y x |> < A , v + v' > ] | S => join(x,y) < A , v + v' > z | S if z := freshD(S) . 
***    rl [DEF-AUTHDIVIDE] :  < A , v + v' > x | S => { A : x v v' } ( < A , v + v' > x | A[ x |> < A , v > < A , v' > ] | S ) .
***    crl [DEF-DIVIDE] :  < A , v + v' > x | A[ x |> < A , v > < A , v' > ] | S  => divide(x,y,y') < A , v > y | < A , v' > y' | S if y := freshD(S) /\ y' := freshD(y,S) .
***    rl [DEF-DONATE] :  < A , v > x | S => { A : x B } ( < A , v > x | A[ x |> B ] | S ) .
***    crl [DEF-DONATE] :  < A , v > x | A[ x |> B ] | S  => donate(x,B) < B , v > y | S if y := freshD(S) .
endm

mod BITML is
    protecting BITML-SEM .
endm

mod ODDS-EVENS is
    protecting BITML .
    
    ops A B : -> Participant [ctor] .    
    ops a b : -> Secret .
    op t : -> Nat .
    op p : -> Predicate .  *** 0 ≤ |b | ≤ 1
    op p1 : -> Predicate . *** |a|  =  |b|
    op p2 : -> Predicate . *** |a| =/= |b|
    op OddsEvens : -> Contract .
    op OddsEvensAdv : -> AdvContract .
    op a : -> Secret .
    ops v v' v'' : -> Value .
    ops x x' x'' y : -> Name .
    op C : -> Contract .
    
    eq OddsEvens = split(
        v(2) ~> ( reveal b if p . withdraw B + after t : withdraw A )
        v(2) ~> ( reveal a . withdraw A + after t : withdraw B )
        v(2) ~> ( reveal (a b) if p1 . withdraw A
                + reveal (a b) if p2 . withdraw B ) ) .
    
    eq OddsEvensAdv = [x("x_0")] < OddsEvens, v(6) > x("x_0") .
    
    op ESsplit : -> AdvContract .
    eq ESsplit = [x("x_0")] < split( v(1) ~> 0 v(2) ~> 0 ), v(3) > x("x_0") .

    op ESreveal : -> AdvContract .
    eq ESreveal = [x("x_0") x("x_1")] < reveal a . 0, v(3) > x("x_0") | B : a # 6 .

    var txs : List{Name} .
    var vs : List{Value} .
    var As : List{Participant} .
    op ESputReveal(_,_,_) : List{Name} List{Value} List{Participant} -> AdvContract .
    eq ESputReveal(txs,vs,As) = 
        [txs y] 
        < put txs reveal a if true . 0, v(3) > y 
        |   (|| As vs txs)
        |   (|| B a 10) .

endm


mod TEST is 
    protecting BITML .
    ops A B A' B' : -> Participant .
    ops x x' x'' : -> Name .
    ops y y' y'' : -> Name .
    ops z z' z'' : -> Name .
    ops v v' v'' : -> Value .
    ops a a' a'' : -> Secret .
    ops b b' b'' : -> Secret .
    ops x^ y^ z^ : -> List{Name} . 
    ops v^ : -> List{Value} . 
    ops a^ b^ : -> List{Secret} . 
    ops t t' : -> Nat .
    ops p p' p'' : -> Predicate .
    ops C C' C'' : -> Contract .
    ops D D' D'' : -> GuardedContract .
    ops l l' l'' : -> Label .
    
    vars SS SS' : Configuration .
    vars ll ll' : Label .
    vars xx^ : List{Name} .
endm

***set trace on .
***trace exclude BOOL EXT-BOOL STRING NAT LIST{Name} LIST{Secret} LIST{SplitEntry} FULL-MAUDE .
***set trace eq on .
***rewrite in TEST : 
***    [x x' x'' y]
***        < put x x' x'' reveal a a'' if true . C, v(10) > y 
***        | < A, v > x | < B, v' > x' | < A', v'' > x''
***        | B : a # 10 | B' : a'' # 4 .

***search in TEST : 
***    [x x' x'' y]
***        < put x x' x'' reveal a a'' if true . C, v(10) > y 
***        | < A, v > x | < B, v' > x' | < A', v'' > x''
***        | B : a # 10 | B' : a'' # 4 
***    =>*
***    {put(x x' x'',a a'',y)}[x x' x'' y x("x_0")]< C,v(10) >
***    x("x_0") | B : a # 10 | B' : a'' # 4
***    .

rewrite in TEST :
     < 0 > [x] < A : after 2 : withdraw B, v > x 
    | A[x |> A : after 2 : withdraw B] .
    
   
    